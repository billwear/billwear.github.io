<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>GoBear — going bare with Go · stormrider</title>
  <meta name="description" content="Learning Go by building a bare-metal provisioner. A release-early, release-often journey with a production-shaped starter.">
  <link rel="icon" href="/favicon.svg" type="image/svg+xml">
  <link rel="stylesheet" href="/styles.css">
</head>
<body>
  <div class="wrap">

    <header class="sec">
      <p><a href="/">← back to billwear</a></p>
      <h1>GoBear — learning Go by building a bare-metal provisioner</h1>
      <p class="lede">A public, release-early, release-often journey. The goal: learn Go while shaping a small, real network service that could grow into a bare-metal provisioner.</p>
      <hr>
    </header>

    <main>
      <section class="sec">
        <h2>Project shape</h2>
        <div class="grid">
          <div class="card">
            <h3>Scope</h3>
            <p>Start as a general-purpose network service with solid bones: structured logging, Prometheus metrics, health endpoints, clean shutdown, and a minimal API. Grow toward PXE/TFTP helpers and a small state store.</p>
          </div>
          <div class="card">
            <h3>Why this order</h3>
            <p>Production-shaped scaffolding first means every experiment runs inside sane boundaries. Learning Go <em>and</em> ops habits at the same time pays long-term dividends.</p>
          </div>
        </div>
      </section>

      <section class="sec">
        <h2>Milestone 0 — a production-shaped starter</h2>
        <p>Bootstrap a single binary that can log, expose metrics, respond to health checks, and shut down gracefully on <code>SIGINT</code>/<code>SIGTERM</code>.</p>

        <h3>go.mod</h3>
        <div class="card">
          <pre><code>module github.com/yourname/gobear

go 1.22

require (
    github.com/prometheus/client_golang v1.18.0
)</code></pre>
        </div>

        <h3>cmd/gobear/main.go</h3>
        <div class="card">
          <pre><code>package main

import (
	"context"
	"errors"
	"fmt"
	"log/slog"
	"net/http"
	"os"
	"os/signal"
	"strconv"
	"syscall"
	"time"

	"github.com/prometheus/client_golang/prometheus/promhttp"
)

// abbreviated for brevity...
func main() {{
	logger := slog.New(slog.NewJSONHandler(os.Stdout, &slog.HandlerOptions{{Level: slog.LevelInfo}}))
	slog.SetDefault(logger)
	logger.Info("starting gobear")
	// mux, handlers, graceful shutdown, etc.
}}
</code></pre>
        </div>

        <h3>Run it</h3>
        <div class="card">
          <pre><code>go mod tidy
go run ./cmd/gobear
# in another shell:
curl -s localhost:8080/healthz
curl -s localhost:8080/
curl -s localhost:8080/metrics | head</code></pre>
        </div>

        <div class="grid">
          <div class="card">
            <h3>What we have now</h3>
            <p>A clean, single binary with structured logs, metrics, health checks, and graceful shutdown — the core of any network service.</p>
          </div>
        </div>
      </section>

      <section class="sec">
        <h2>Milestone 1 — configuration &amp; layout</h2>
        <ul>
          <li><strong>Project layout:</strong> <code>cmd/gobear/</code> for the main, <code>internal/</code> for private packages, <code>pkg/</code> for public ones later.</li>
          <li><strong>Env-first config:</strong> environment variables with sane defaults; support YAML/TOML later if needed.</li>
          <li><strong>Build metadata:</strong> inject <code>version</code>, <code>commit</code>, <code>date</code> via <code>-ldflags</code> to print at startup.</li>
        </ul>

        <h3>Version injection</h3>
        <div class="card">
          <pre><code>// inside main.go
var (
    version = "dev"
    commit  = "none"
    date    = "unknown"
)
logger.Info("build", "version", version, "commit", commit, "date", date)
</code></pre>
          <pre><code># build with metadata
go build -ldflags "-X main.version=$(git describe --tags --always) \
 -X main.commit=$(git rev-parse --short HEAD) \
 -X main.date=$(date -u +%Y-%m-%dT%H:%M:%SZ)" ./cmd/gobear</code></pre>
        </div>
      </section>

      <section class="sec">
        <h2>Milestone 2 — a tiny API for provisioning</h2>
        <p>Start with a simulated provisioning workflow that returns a token. No PXE yet — just shape the flow.</p>
        <div class="card">
          <pre><code>// add to mux in main()
mux.HandleFunc("/api/v1/provision", func(w http.ResponseWriter, r *http.Request) {
    if r.Method != http.MethodPost {
        w.WriteHeader(http.StatusMethodNotAllowed); return
    }
    token := fmt.Sprintf("pxe_%d", time.Now().Unix())
    w.Header().Set("Content-Type", "application/json")
    fmt.Fprintf(w, `{"token":"%s"}`, token)
})</code></pre>
        </div>
        <div class="card">
          <pre><code># try it
curl -s -X POST localhost:8080/api/v1/provision</code></pre>
        </div>
        <div class="grid">
          <div class="card">
            <h3>Why a fake first?</h3>
            <p>Design the request/response and logging paths before touching PXE/TFTP. It keeps learning focused and increments small.</p>
          </div>
        </div>
      </section>

      <section class="sec">
        <h2>Milestone 3 — health, readiness, and metrics</h2>
        <ul>
          <li><strong>/healthz</strong>: quick “am I alive?”</li>
          <li><strong>/readyz</strong>: add checks for dependencies (e.g., can we read a state file?)</li>
          <li><strong>/metrics</strong>: Prometheus handler already mounted</li>
        </ul>
        <div class="card">
          <pre><code>// example readiness check
mux.HandleFunc("/readyz", func(w http.ResponseWriter, r *http.Request) {
    if _, err := os.Stat("state.db"); err == nil {
        w.Write([]byte("ready")); return
    }
    w.WriteHeader(http.StatusServiceUnavailable)
    w.Write([]byte("not ready"))
})</code></pre>
        </div>
      </section>

      <section class="sec">
        <h2>Milestone 4 — next steps toward a provisioner</h2>
        <ul>
          <li><strong>PXE notes:</strong> A minimal PXE flow needs DHCP options (66/67), a TFTP server, and kernel/initrd with a preseed or cloud-init data source.</li>
          <li><strong>State:</strong> Start with a tiny BoltDB/SQLite or JSON file for requests and tokens.</li>
          <li><strong>Templates:</strong> Render cloud-init or iPXE templates from Go to hand to clients.</li>
          <li><strong>CLI:</strong> Add <code>--addr</code> flags using the standard <code>flag</code> package.</li>
        </ul>
      </section>

      <section class="sec">
        <h2>Release early, release often</h2>
        <div class="card">
          <pre><code># quick quality loop
go test ./...
golangci-lint run   # if you add it
go build ./cmd/gobear
./gobear</code></pre>
        </div>
        <p>Commit small, runnable changes. Keep a CHANGELOG. Tag “walkable” points even if features are thin. The habit matters more than the scope in the early days.</p>
      </section>
    </main>

    <footer class="sec">
      <hr>
      <p>CC BY-NC 2025 · stormrider · Go 1.22 · Prometheus client_golang · structured logs via slog</p>
    </footer>

  </div>
</body>
</html>
