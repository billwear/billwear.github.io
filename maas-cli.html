<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2023-12-21 Thu 13:00 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>SR-MAAS CLI</title>
<meta name="author" content="stormrider" />
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" type="text/css" href="css/stylesheet.css" />
</head>
<body>
<div id="preamble" class="status">
<a href="https://stormrider.io">Home</a> ~ <a href="https://stormrider.io/about-me.html">About</a> ~ <a href="https://stormrider.io/arcana.html">Arcana</a> ~ <a href="https://stormrider.io/open-source.html">Open Source</a>
</div>
<div id="content" class="content">
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org788be05">Installing MAAS</a>
<ul>
<li><a href="#org907d04f">Production postgres</a></li>
<li><a href="#org815c840">Initialising MAAS</a></li>
</ul>
</li>
<li><a href="#orgb952793">Configuring MAAS</a>
<ul>
<li><a href="#org70e1f8e">Logging in</a></li>
<li><a href="#org582d0c8">Getting real help</a></li>
<li><a href="#orge19aba2">Setting dns</a></li>
<li><a href="#orgcad98cc">Importing images</a></li>
<li><a href="#org329811f">Enter jq</a></li>
</ul>
</li>
<li><a href="#org3d2bea1">Enabling DHCP</a></li>
<li><a href="#org7b250ea">Commissioning machines</a></li>
<li><a href="#orgba84949">Deploying machines</a>
<ul>
<li><a href="#org57bb4f2">Acquiring a machine using the CLI</a></li>
<li><a href="#orgbd9b32b">Deploying a machine with the CLI</a></li>
</ul>
</li>
<li><a href="#org07d11b0">jq tricks</a>
<ul>
<li><a href="#orgb7d8a67">Basic jq usage</a></li>
<li><a href="#org59373cc">Improved formatting</a></li>
<li><a href="#org93a12fe">Making real tables</a></li>
<li><a href="#org159f43c">Extending the list</a></li>
<li><a href="#org9798af9">Nested arrays</a></li>
<li><a href="#org083446b">Nested keys</a></li>
<li><a href="#orgea57b16">Chaining Ubuntu CLI commands</a></li>
</ul>
</li>
<li><a href="#orgdb84081">SSH/SCP with MAAS machines</a>
<ul>
<li><a href="#org2ae5039">Create a KVM</a></li>
<li><a href="#orge05ae5c">Composing a machine</a></li>
<li><a href="#orge4be9fd">Getting the machine to a login state</a></li>
<li><a href="#org8507ef7">Logging into a commissioned machine</a></li>
<li><a href="#orge68e360">Using SCP</a></li>
<li><a href="#org2cd19df">Copying files to a deployed machine</a></li>
<li><a href="#orgca07192">Copying a script over there and running it</a></li>
</ul>
</li>
<li><a href="#orge35259c">More neat jq things</a>
<ul>
<li><a href="#orgf094277">Sorting natively with jq</a></li>
<li><a href="#orgb503c03">jq is not UNIX (jqNU?)</a></li>
<li><a href="#orgb1d1554">So how does "sortby()" work?</a></li>
<li><a href="#org6b88ec6">Checking our work</a></li>
<li><a href="#org03cb843">Sorting by more than one parameter</a></li>
</ul>
</li>
</ul>
</div>
</div>
<p>
I'm going to configure MAAS via the command-line only &#x2013; and write about it. MAAS has a really nice UI that's super-easy to use, and a CLI backed by a REST API. I'd really like to try to see how much I can do, and how far I can get, using just the CLI.
So my goals for this project are simple: run MAAS through its paces using only the CLI and take good notes.
</p>

<div id="outline-container-org788be05" class="outline-2">
<h2 id="org788be05">Installing MAAS</h2>
<div class="outline-text-2" id="text-org788be05">
<p>
It starts with installation. I'm doing this experiment on my largest laptop, wintermute (named after the character in Neuromancer).  I mention that only because you'll sometimes see that hostname behind the prompt in the examples below.
</p>

<p>
Let's be naive and start from first installation. I've cleared MAAS off wintermute, as well as PostgreSQL, so I can try a true, out of box experience. I haven't cleaned off libvirt or any of my KVMs I've got on here, nor the bridge I created to network them, because I use those for other things &#x2013; and because it's reasonable to expect that someone who's looking at MAAS would have some kind of virtual machine capability around already.
</p>

<p>
So starting at the top of the MAAS 2.8 install instructions, I'm going to first "install (but not initialize) the MAAS snap":
</p>

<p>
<textarea cols="80" rows="2">
stormrider@wintermute:~$ sudo snap install maas --channel=2.8
maas (2.8/stable) 2.8.1-8567-g.c4825ca06 from Canonical installed</textarea>
</p>

<p>
Looking over my MAAS initialisation modes, I see that region+rack mode will do fine for this install, as I don't have to add the complexity of separate rack controllers just yet. I can do that later, if I get that far. But it's not quite time to initialise, though; I need to make a decision whether I want a production install or just a proof-of-concept setup. I've already removed PostgreSQL so that I can choose either one.
</p>
</div>

<div id="outline-container-org907d04f" class="outline-3">
<h3 id="org907d04f">Production postgres</h3>
<div class="outline-text-3" id="text-org907d04f">
<p>
For now, I think I'm going with the production configuration (more to see and do), and that starts with a local PostgreSQL install, from packages. And, like most Debian installs, that starts with an update, to grab any packages that might need to be available for the install to succeed:
</p>

<p>
<textarea cols="80" rows="24">
stormrider@wintermute:~$ sudo apt update -y

[sudo] password for stormrider: 
Hit:1 http://dl.google.com/linux/chrome/deb stable InRelease
Hit:2 http://us.archive.ubuntu.com/ubuntu focal InRelease                                      
Get:3 http://security.ubuntu.com/ubuntu focal-security InRelease [107 kB]
Get:4 http://us.archive.ubuntu.com/ubuntu focal-updates InRelease [111 kB]
Get:5 http://us.archive.ubuntu.com/ubuntu focal-backports InRelease [98.3 kB]
Get:6 http://us.archive.ubuntu.com/ubuntu focal-updates/main amd64 Packages [310 kB]
Get:7 http://security.ubuntu.com/ubuntu focal-security/main amd64 DEP-11 Metadata [21.2 kB]
Get:8 http://us.archive.ubuntu.com/ubuntu focal-updates/main i386 Packages [187 kB]     
Get:9 http://us.archive.ubuntu.com/ubuntu focal-updates/main amd64 DEP-11 Metadata [196 kB]
Get:10 http://us.archive.ubuntu.com/ubuntu focal-updates/universe amd64 Packages [142 kB]
Get:11 http://us.archive.ubuntu.com/ubuntu focal-updates/universe i386 Packages [77.6 kB]
Get:12 http://security.ubuntu.com/ubuntu focal-security/universe amd64 DEP-11 Metadata [35.8 kB]
Get:13 http://us.archive.ubuntu.com/ubuntu focal-updates/universe Translation-en [71.7 kB]
Get:14 http://us.archive.ubuntu.com/ubuntu focal-updates/universe amd64 DEP-11 Metadata [176 kB]
Get:15 http://us.archive.ubuntu.com/ubuntu focal-updates/multiverse amd64 DEP-11 Metadata [2,468 B]
Get:16 http://us.archive.ubuntu.com/ubuntu focal-backports/universe amd64 DEP-11 Metadata [1,972 B]
Fetched 1,538 kB in 2s (827 kB/s)                                             
Reading package lists... Done
Building dependency tree       
Reading state information... Done
325 packages can be upgraded. Run 'apt list --upgradable' to see them.</textarea>
</p>

<p>
Then I can install PostgreSQL, probably version 12 or something like that:
</p>

<p>
<textarea cols="80" rows="27">
stormrider@wintermute:~$ sudo apt install -y postgresql</strong>

Reading package lists... Done
Building dependency tree       
Reading state information... Done
The following packages were automatically installed and are no longer required:
enchant geoip-database gir1.2-mutter-5 gsfonts libbind9-161 libcroco3 libdns-export1107
libdns1107 libdns1109 libenchant1c2a libfprint0 libgeoip1 libgnome-desktop-3-18 libirs161
libisc-export1104 libisc1104 libisc1105 libisccc161 libisccfg163 liblwres161 libmicrodns0
libmutter-5-0 liboauth0 libpoppler90 libpython3.7 libpython3.7-minimal libpython3.7-stdlib
linux-image-5.3.0-40-generic linux-modules-5.3.0-40-generic
linux-modules-extra-5.3.0-40-generic ubuntu-software ubuntu-system-service
Use 'sudo apt autoremove' to remove them.
Suggested packages:
postgresql-doc
The following NEW packages will be installed:
postgresql
0 upgraded, 1 newly installed, 0 to remove and 325 not upgraded.
Need to get 4,004 B of archives.
After this operation, 67.6 kB of additional disk space will be used.
Get:1 http://us.archive.ubuntu.com/ubuntu focal/main amd64 postgresql all 12+214 [4,004 B]
Fetched 4,004 B in 0s (13.2 kB/s)     
Selecting previously unselected package postgresql.
(Reading database ... 227326 files and directories currently installed.)
Preparing to unpack .../postgresql_12+214_all.deb ...
Unpacking postgresql (12+214) ...
Setting up postgresql (12+214) ...</textarea>
</p>

<p>
Yep, version 12. I like keeping up. Anyway, now I need to set up a PostgreSQL user:
</p>

<p>
<textarea cols="80" rows="2">
stormrider@wintermute:~$<strong>sudo -u postgres psql -c "CREATE USER \"maascli\" WITH ENCRYPTED PASSWORD 'maascli'"
CREATE ROLE</textarea>
</p>

<p>
And create a suitable MAAS database:
</p>

<p>
<textarea cols="80" rows="1">
stormrider@wintermute:~$<strong>sudo -u postgres createdb -O "maascli" "maasclidb"</textarea>
</p>

<p>
Note that there's no system response (the old UNIX rule of "no news is good news"). Next, I need to add the database to the PostgreSQL HBA configuration, by editing `/etc/postgres/12/main/pghba.conf', adding a line to the bottom of the file:
</p>

<p>
<textarea cols="80" rows="2">
stormrider@wintermute:~$<strong>sudo vi /etc/postgresql/12/main/pg_hba.conf</strong>
host    maasclidb       maascli         0/0                     md5</textarea>
</p>
</div>
</div>

<div id="outline-container-org815c840" class="outline-3">
<h3 id="org815c840">Initialising MAAS</h3>
<div class="outline-text-3" id="text-org815c840">
<p>
Finally, I can initialise MAAS, like this:
</p>

<p>
<textarea cols="80" rows="2">
stormrider@wintermute:~$<strong>sudo maas init region+rack --database-uri "postgres://maascli:maascli@localhost/maasclidb"
MAAS URL [default=http://192.168.43.251:5240/MAAS]: </textarea>
</p>

<p>
This command offers me a bit of important feedback, the MAAS URL, which will be needed for the CLI login. That's followed by a running commentary on the steps MAAS is taking to start up. It all ends with the following admonition:
</p>

<p>
<textarea cols="80" rows="10">
MAAS has been set up.

If you want to configure external authentication or use
MAAS with Canonical RBAC, please run

sudo maas configauth

To create admins when not using external authentication, run

sudo maas createadmin</textarea>
</p>

<p>
Well, that's an easy call. Let me just run &lt;code&gt;createadmin&lt;/code&gt; real quick:
</p>

<p>
<textarea cols="80" rows="7">
stormrider@wintermute:~$<strong>sudo maas createadmin
[sudo] password for stormrider: 
Username: admin
Password: 
Again: 
Email: admin@admin.com
Import SSH keys [] (lp:user-id or gh:user-id): xxxxxxxxxxx</textarea>
</p>
</div>
</div>
</div>

<div id="outline-container-orgb952793" class="outline-2">
<h2 id="orgb952793">Configuring MAAS</h2>
<div class="outline-text-2" id="text-orgb952793">
<p>
Now that <a href="https://stormrider.io/maas-cli-1.html">MAAS is up and running</a>, it's time to configure it. Normally, this would be accomplished through the MAAS configuration journey, but since I'm using the CLI for this, I want to avoid the UI as much as possible.
</p>
</div>

<div id="outline-container-org70e1f8e" class="outline-3">
<h3 id="org70e1f8e">Logging in</h3>
<div class="outline-text-3" id="text-org70e1f8e">
<p>
The first step in the config journey is logging in. In the CLI, that's a two-stepper:
</p>

<p>
<textarea cols="80" rows="2">
stormrider@wintermute:~$  sudo maas apikey --username=admin > api-key-file 
sudo maas apikey --username=admin > api-key-file</textarea>
</p>

<p>
You can make sure you got a valid API key by displaying the contents of api-key-file:
</p>

<p>
<textarea cols="80" rows="2">
stormrider@wintermute:~$  cat api-key-file 
XXEjkeeqM:zXb7LkuPY7VxShFNhCFDaD8WnP8gLVL8V64GbSn:tTKdwWV64GbSn:tTKdwW</textarea>
</p>

<p>
Note that string isn't an actual API key, just characters I made up.
Anyway, I can now login to MAAS &#x2013; but first, let's try maas &#x2013;help &#x2013; there's an important distinction that gets skipped over, causing some grief:
</p>

<p>
<textarea cols="80" rows="22">
stormrider@wintermute:~$  maas --help 
usage: maas [-h] COMMAND ...

optional arguments:
   -h, --help      show this help message and exit

drill down:
   COMMAND
      login         Log in to a remote API, and remember its description and credentials.
      logout        Log out of a remote API, purging any stored credentials.
      list          List remote APIs that have been logged-in to.
      refresh       Refresh the API descriptions of all profiles.
      init          Initialise MAAS in the specified run mode.
      config        View or change controller configuration.
      status        Status of controller services.
      migrate       Perform migrations on connected database.
      apikey        Used to manage a user's API keys. Shows existing keys unless --generate or --delete is passed.
      configauth    Configure external authentication.
      createadmin   Create a MAAS administrator account.
      changepassword
                    Change a MAAS user's password.
      admin         Interact with http://192.168.43.251:5240/MAAS/api/2.0/</textarea>
</p>


<p>
This is the help you get (a) if you're not logged in, or (b) if you don't type a logged-in username after maas - which is a little annoying to me, but it's just how we do it. What you see above isn't even half of what the MAAS CLI will do, but it's all you get as an unrecognized user.
</p>

<p>
So now, let's login and try that help again:
</p>

<p>
<textarea cols="80" rows="8">
stormrider@wintermute:~$  maas login admin http://192.168.43.251:5240/MAAS/api/2.0/ < api-key-file 

You are now logged in to the MAAS server at
http://192.168.43.251:5240/MAAS/api/2.0/ with the profile name 'admin'.

For help with the available commands, try:

maas admin --help</textarea>
</p>
</div>
</div>

<div id="outline-container-org582d0c8" class="outline-3">
<h3 id="org582d0c8">Getting real help</h3>
<div class="outline-text-3" id="text-org582d0c8">
<p>
Now, having done that, I can get a much better idea what the CLI will do:
</p>

<p>
<textarea cols="80" rows="125">
stormrider@wintermute:~$ maas admin --help 

usage: maas admin [-h] COMMAND ...

Issue commands to the MAAS region controller at http://192.168.43.251:5240/MAAS/api/2.0/.

optional arguments:
   -h, --help            show this help message and exit

drill down:
   COMMAND
      account             Manage the current logged-in user.
      bcache-cache-set    Manage bcache cache set on a machine.
      bcache-cache-sets   Manage bcache cache sets on a machine.
      bcache              Manage bcache device on a machine.
      bcaches             Manage bcache devices on a machine.
      block-device        Manage a block device on a machine.
      block-devices       Manage block devices on a machine.
      boot-resource       Manage a boot resource.
      boot-resources      Manage the boot resources.
      boot-source         Manage a boot source.
      boot-source-selection
                          Manage a boot source selection.
      boot-source-selections
                          Manage the collection of boot source selections.
      boot-sources        Manage the collection of boot sources.
      commissioning-script
                          Manage a custom commissioning script.
      commissioning-scripts
                          Manage custom commissioning scripts.
      dhcpsnippet         Manage an individual DHCP snippet.
      dhcpsnippets        Manage the collection of all DHCP snippets in MAAS.
      dnsresource         Manage dnsresource.
      dnsresource-record  Manage dnsresourcerecord.
      dnsresource-records
                          Manage DNS resource records (e.g. CNAME, MX, NS, SRV, TXT)
      dnsresources        Manage dnsresources.
      device              Manage an individual device.
      devices             Manage the collection of all the devices in the MAAS.
      discoveries         Query observed discoveries.
      discovery           Read or delete an observed discovery.
      domain              Manage domain.
      domains             Manage domains.
      events              Retrieve filtered node events.
      fabric              Manage fabric.
      fabrics             Manage fabrics.
      fan-network         Manage Fan Network.
      fan-networks        Manage Fan Networks.
      file                Manage a FileStorage object.
      files               Manage the collection of all the files in this MAAS.
      ipaddresses         Manage IP addresses allocated by MAAS.
      iprange             Manage IP range.
      ipranges            Manage IP ranges.
      interface           Manage a node's or device's interface.
      interfaces          Manage interfaces on a node.
      license-key         Manage a license key.
      license-keys        Manage the license keys.
      maas                Manage the MAAS server.
      machine             Manage an individual machine.
      machines            Manage the collection of all the machines in the MAAS.
      network             Manage a network.
      networks            Manage the networks.
      node                Manage an individual Node.
      node-results        Read the collection of commissioning script results.
      node-script         Manage or view a custom script.
      node-script-result  Manage node script results.
      node-script-results
                          Manage node script results.
      node-scripts        Manage custom scripts.
      nodes               Manage the collection of all the nodes in the MAAS.
      notification        Manage an individual notification.
      notifications       Manage the collection of all the notifications in MAAS.
      package-repositories
                          Manage the collection of all Package Repositories in MAAS.
      package-repository  Manage an individual package repository.
      partition           Manage partition on a block device.
      partitions          Manage partitions on a block device.
      pod                 Manage an individual pod.
      pods                Manage the collection of all the pod in the MAAS.
      rack-controller     Manage an individual rack controller.
      rack-controllers    Manage the collection of all rack controllers in MAAS.
      raid                Manage a specific RAID (Redundant Array of Independent
                          Disks) on a machine.
      raids               Manage all RAIDs (Redundant Array of Independent Disks) on
                          a machine.
      region-controller   Manage an individual region controller.
      region-controllers  Manage the collection of all region controllers in MAAS.
      resource-pool       Manage a resource pool.
      resource-pools      Manage resource pools.
      sshkey              Manage an SSH key.
      sshkeys             Manage the collection of all the SSH keys in this MAAS.
      sslkey              Manage an SSL key.
      sslkeys             Operations on multiple keys.
      space               Manage space.
      spaces              Manage spaces.
      static-route        Manage static route.
      static-routes       Manage static routes.
      subnet              Manage subnet.
      subnets             Manage subnets.
      tag                 Tags are properties that can be associated with a Node and
                          serve as criteria for selecting and allocating nodes.
      tags                Manage all tags known to MAAS.
      user                Manage a user account.
      users               Manage the user accounts of this MAAS.
      version             Information about this MAAS instance.
      virtual-machine     Manage individual virtual machines.
      virtual-machines    Manage a collection of virtual machines.
      vlan                Manage a VLAN on a fabric.
      vlans               Manage VLANs on a fabric.
      vm-host             Manage an individual vm-host.
      vm-hosts            Manage the collection of all the vm-hosts in the MAAS.
      vmfs-datastore      Manage VMFS datastore on a machine.
      vmfs-datastores     Manage VMFS datastores on a machine.
      volume-group        Manage volume group on a machine.
      volume-groups       Manage volume groups on a machine.
      zone                Manage a physical zone.
      zones               Manage physical zones.

      This is a profile.  Any commands you issue on this profile will
      operate on the MAAS region server.

      The command information you see here comes from the region server's
      API; it may differ for different profiles.  If you believe the API may
      have changed, use the command's 'refresh' sub-command to fetch the
      latest version of this help information from the server.</textarea>
</p>

<p>
Wowee! Look at all the commands! The very first time I tried to use the MAAS API (before I actually hired on at Canonical), I was using various commands I could find in the documentation that actually returned things I wanted, and then digging it out of the JSON output. Not fun. Then someone reminded me about <code>jq</code> (we'll come to that in a minute), and things got a little easier. Eventually, I asked one of the developers what the deal was, and learned that I just missed a the section called "Get help" in the CLI introduction. After that, a whole new world opened up.
</p>

<p>
But we came here to configure MAAS, not tell stories, so let me see what I can do with this beast.
</p>
</div>
</div>

<div id="outline-container-orge19aba2" class="outline-3">
<h3 id="orge19aba2">Setting dns</h3>
<div class="outline-text-3" id="text-orge19aba2">
<p>
The very first blank line you encounter in the MAAS UI is the DNS server IP address. In the UI, I just type "8.8.8.8" (Google's DNS server) and forget about it. But the CLI has no box, so how do I get there? Well, there is a subcommand called &lt;code&gt;dnsresource~, let's see what that does.
</p>

<p>
<textarea cols="80" rows="13">
stormrider@wintermute:~$  maas admin dnsresource --help 
Usage: maas admin dnsresource [-h] COMMAND ...

Manage dnsresource.

optional arguments:
   -h, --help  show this help message and exit

drill down:
   COMMAND
      read      Read a DNS resource
      update    Update a DNS resource
      delete    Delete a DNS resource</textarea>
</p>

<p>
Okay, let's be naive and try that:
</p>

<p>
<textarea cols="80" rows="16">
stormrider@wintermute:~$  maas admin dnsresource read 
Usage: maas admin dnsresource read [--help] [-d] [-k] id [data [data ...]]

Read a DNS resource

positional arguments:
   id
   data

optional arguments:
   --help, -h      Show this help message and exit.
   -d, --debug     Display more information about API responses.
   -k, --insecure  Disable SSL certificate check

Read a DNS resource by id.
   the following arguments are required: id, data</textarea>
</p>

<p>
Well, that isn't going to help me, I don't have any idea what the "dnsresource id" would be. Hmmm. Oh, wait. This CLI follows the "collection-instance" rule, that is, listing DNS resources would be part of a collection, so would be pluralized. So, for example, I can read &lt;code&gt;dnsresources~ (plural) and maybe find out something:
</p>

<p>
<textarea cols="80" rows="4">
stormrider@wintermute:~$  maas admin dnsresources read 
Success.
Machine-readable output follows:
[]</textarea>
</p>

<p>
Well. Maybe I should try the CLI documentation. Looking at the "Quick questions" under common tasks, I see there's one about setting a DNS forwarder. Let me check that out. Hmmm, yeah, that might be what I want. There's a easy way to tell: I can check the DNS setting in the MAAS dashboard in the UI, run the CLI command I found, and see if that sets it.
</p>

<p>
Okay, actually, I cheated first. I went and asked my friend Lee, who knows how this works, and I kept asking until I annoyed him. But it's useful to illustrate that there was a way to get this from the doc and experimentation, which I should have done. * Sorry, Lee. Owe you lunch. Maybe that's two lunches. *
</p>

<p>
Hey, in that field, it even says "DNS forwarder" &#x2013; so let me try it:
</p>

<p>
<textarea cols="80" rows="4">
stormrider@wintermute:~$  maas admin maas set-config name=upstream_dns value="8.8.8.8" 
Success.
Machine-readable output follows:
OK</textarea>
</p>

<p>
And it sets it! Woo-hoo, it worked! It wasn't obvious whether I needed to type the IP address with quotes, but I did, and it paid off. I guess I could try it without quotes to see what happens:
</p>

<p>
<textarea cols="80" rows="4">
stormrider@wintermute:~$ maas admin maas set-config name=upstream_dns value=9.9.9.9 
Success.
Machine-readable output follows:
OK</textarea>
</p>

<p>
And that works, too, so I'll change it back real fast before weird things start to happen, since I have no idea what "9.9.9.9" is.
</p>

<p>
note to self:  <i>always</i> RTFM. before annoying my friend Lee. 
</p>
</div>
</div>

<div id="outline-container-orgcad98cc" class="outline-3">
<h3 id="orgcad98cc">Importing images</h3>
<div class="outline-text-3" id="text-orgcad98cc">
<p>
The next thing would be to import images. When I look at the dashboard, it's already been done, but TBH it was already synched when I logged in and opened the dashboard, so it must be automatic for at least one default image. Dunno. But I can bring in some other image (like Ubuntu 16.04 LTS) just to see how that works, and I can figure out how to confirm that the 18.04 (default) image is actually here.
</p>

<p>
Well, this time actually consulting the manual, it says I can confirm 18.04 by entering the following command:
</p>

<p>
<textarea cols="80" rows="1">
stormrider@wintermute:~$  maas admin boot-resources read </textarea>
</p>

<p>
The JSON resulting from this command is rather lengthy:
</p>

<p>
<textarea cols="80" rows="80">
Success.
Machine-readable output follows:
[
    {
        "id": 7,
        "type": "Synced",
        "name": "grub-efi-signed/uefi",
        "architecture": "amd64/generic",
        "resource_uri": "/MAAS/api/2.0/boot-resources/7/"
    },
    {
        "id": 8,
        "type": "Synced",
        "name": "grub-efi/uefi",
        "architecture": "arm64/generic",
        "resource_uri": "/MAAS/api/2.0/boot-resources/8/"
    },
    {
        "id": 9,
        "type": "Synced",
        "name": "grub-ieee1275/open-firmware",
        "architecture": "ppc64el/generic",
        "resource_uri": "/MAAS/api/2.0/boot-resources/9/"
    },
    {
        "id": 10,
        "type": "Synced",
        "name": "pxelinux/pxe",
        "architecture": "i386/generic",
        "resource_uri": "/MAAS/api/2.0/boot-resources/10/"
    },
    {
        "id": 1,
        "type": "Synced",
        "name": "ubuntu/bionic",
        "architecture": "amd64/ga-18.04",
        "resource_uri": "/MAAS/api/2.0/boot-resources/1/",
        "subarches": "generic,hwe-p,hwe-q,hwe-r,hwe-s,hwe-t,hwe-u,hwe-v,hwe-w,ga-16.04,ga-16.10,ga-17.04,ga-17.10,ga-18.04"
    },
    {
        "id": 2,
        "type": "Synced",
        "name": "ubuntu/bionic",
        "architecture": "amd64/ga-18.04-lowlatency",
        "resource_uri": "/MAAS/api/2.0/boot-resources/2/",
        "subarches": "generic,hwe-p,hwe-q,hwe-r,hwe-s,hwe-t,hwe-u,hwe-v,hwe-w,ga-16.04,ga-16.10,ga-17.04,ga-17.10,ga-18.04"
    },
    {
        "id": 3,
        "type": "Synced",
        "name": "ubuntu/bionic",
        "architecture": "amd64/hwe-18.04",
        "resource_uri": "/MAAS/api/2.0/boot-resources/3/",
        "subarches": "generic,hwe-p,hwe-q,hwe-r,hwe-s,hwe-t,hwe-u,hwe-v,hwe-w,ga-16.04,ga-16.10,ga-17.04,ga-17.10,ga-18.04"
    },
    {
        "id": 4,
        "type": "Synced",
        "name": "ubuntu/bionic",
        "architecture": "amd64/hwe-18.04-edge",
        "resource_uri": "/MAAS/api/2.0/boot-resources/4/",
        "subarches": "generic,hwe-p,hwe-q,hwe-r,hwe-s,hwe-t,hwe-u,hwe-v,hwe-w,ga-16.04,ga-16.10,ga-17.04,ga-17.10,ga-18.04,hwe-18.10,hwe-19.04"
    },
    {
        "id": 5,
        "type": "Synced",
        "name": "ubuntu/bionic",
        "architecture": "amd64/hwe-18.04-lowlatency",
        "resource_uri": "/MAAS/api/2.0/boot-resources/5/",
        "subarches": "generic,hwe-p,hwe-q,hwe-r,hwe-s,hwe-t,hwe-u,hwe-v,hwe-w,ga-16.04,ga-16.10,ga-17.04,ga-17.10,ga-18.04"
    },
    {
        "id": 6,
        "type": "Synced",
        "name": "ubuntu/bionic",
        "architecture": "amd64/hwe-18.04-lowlatency-edge",
        "resource_uri": "/MAAS/api/2.0/boot-resources/6/",
        "subarches": "generic,hwe-p,hwe-q,hwe-r,hwe-s,hwe-t,hwe-u,hwe-v,hwe-w,ga-16.04,ga-16.10,ga-17.04,ga-17.10,ga-18.04,hwe-18.10,hwe-19.04"
    }
]</textarea>
</p>

<p>
Okay, that's a lot of information, but it looks like I have a bunch of 18.04 images downloaded and synched. Let me try to get a little fancy with a grep and see if I can make that list shorter:
</p>

<p>
<textarea cols="80" rows="1">
stormrider@wintermute:~$  maas admin boot-resources read | grep architecture </textarea>
</p>

<p>
This produces a quick list of the images I've successfully downloaded:
</p>

<p>
<textarea cols="80" rows="10">
"architecture": "amd64/generic",
"architecture": "arm64/generic",
"architecture": "ppc64el/generic",
"architecture": "i386/generic",
"architecture": "amd64/ga-18.04",
"architecture": "amd64/ga-18.04-lowlatency",
"architecture": "amd64/hwe-18.04",
"architecture": "amd64/hwe-18.04-edge",
"architecture": "amd64/hwe-18.04-lowlatency",
"architecture": "amd64/hwe-18.04-lowlatency-edge",</textarea>
</p>

<p>
That definitely confirms 18.04. But what are those three or four on top? Looking at the massive JSON output, I can see that they have names like "open-firmware," "uefi," and "pxe." Okay, so those are images that can PXE-boot machines, basically. But how could I sort this information out in a neat way?
</p>
</div>
</div>

<div id="outline-container-org329811f" class="outline-3">
<h3 id="org329811f">Enter jq</h3>
<div class="outline-text-3" id="text-org329811f">
<p>
If you're going to use the MAAS CLI &#x2013; or anything with JSON-based output &#x2013; you'll want to consider learning the command line tool <a href="https://stedolan.github.io/jq/">jq</a>. It's quite handy for parsing the JSON output of the MAAS CLI. So, for example, if I want a (sorta) formatted table of names and architectures, I can run my last command through jq like this:
</p>

<p>
<textarea cols="80" rows="1">
stormrider@wintermute:~$  maas admin boot-resources read | jq -r '.[] | "\(.name)\t\(.architecture)"' </textarea>
</p>

<p>
This gives me a clean image list that looks something like this:
</p>

<p>
<textarea cols="80" rows="10">
grub-efi-signed/uefi         amd64/generic
grub-efi/uefi                arm64/generic
grub-ieee1275/open-firmware  ppc64el/generic
pxelinux/pxe                 i386/generic
ubuntu/bionic                amd64/ga-18.04
ubuntu/bionic                amd64/ga-18.04-lowlatency
ubuntu/bionic                amd64/hwe-18.04
ubuntu/bionic                amd64/hwe-18.04-edge
ubuntu/bionic                amd64/hwe-18.04-lowlatency
ubuntu/bionic                amd64/hwe-18.04-lowlatency-edge</textarea>
</p>

<p>
Okay, I cheated just a little there, too: I cleaned up the tabs a little, which wouldn't be quite as well lined-up unless you have a really wide tab setting (which is possible). Even what I did isn't enough to straighten it out totally, but the output is still readable, anyway.
</p>

<p>
So you can see that I basically have (a) the images I need to boot machines, and (b) an 18.04 image (set) to deploy. That's a good start, but let me see if I can pull down another image with the CLI. I know I can select images with the boot-source-selections command, so let me try that with "Trusty" (Xenial Xerus, aka 16.04):
</p>

<p>
<textarea cols="80" rows="3">
stormrider@wintermute:~$ maas admin boot-source-selections create 1 \
  > os="ubuntu" release="trusty" arches="amd64" subarches="*" \
  > labels="*"
</textarea>
</p>

<p>
The results look like this:
</p>

<p>
<textarea cols="80" rows="18">
Success.
Machine-readable output follows:
{
    "os": "ubuntu",
    "release": "trusty",
    "arches": [
        "amd64"
    ],
    "subarches": [
        "*"
    ],
    "labels": [
        "*"
    ],
    "boot_source_id": 1,
    "id": 2,
    "resource_uri": "/MAAS/api/2.0/boot-sources/1/selections/2/"
}</textarea>
</p>

<p>
And that appeared to work, which is good, because that was a long command to type correctly! Sure enough, if I look back at my "Images" tab in the UI, 14.04 LTS is now "Selected for download." Okay, this CLI seems to be working fairly well, let me just keep going and see if I can get it to download, now.
</p>

<p>
In reality, downloading them &#x2013; ahem, I mean "importing" them &#x2013; is a fairly simple command:
</p>

<p>
<textarea cols="80" rows="4">
stormrider@wintermute:~$ maas admin boot-resources import 
Success.
Machine-readable output follows:
Import of boot resources started</textarea>
</p>

<p>
Now when I switch back to the Images screen, I can see that 14.04 LTS is downloading, which is fantastic. 
</p>
</div>
</div>
</div>

<div id="outline-container-org3d2bea1" class="outline-2">
<h2 id="org3d2bea1">Enabling DHCP</h2>
<div class="outline-text-2" id="text-org3d2bea1">
<p>
Of course, the whole point here is to get machines deployed. The next step is to get DHCP working, which means I have to find the untagged VLAN. In truth, it shouldn't be too hard, because at this point, there still should only be one.
</p>

<p>
In order to turn on DHCP, I need to know two things besides the VLAN name ("untagged"): I need to know the fabric ID and the primary rack controller name. Actually, to start with, all the fabrics will be on the same untagged VLAN, so any fabric will do. In turn, I can find a valid fabric ID by reading it from any subnet, so I'll just pick one I know (192.168.123.0/24, the subnet for my virtual bridge). That means I can find a usable fabric ID like this:
</p>

<p>
<textarea cols="80" rows="2">
stormrider@wintermute:~$  maas admin subnet read 192.168.123.0/24 | grep fabric_id 
"fabric_id": 2,</textarea>
</p>

<p>
Then I need to find the name of the primary rack controller. I think it's going to be my laptop hostname, but for purposes of argument, I'll assume that I don't know it and get it this way:
</p>

<p>
<textarea cols="80" rows="2">
stormrider@wintermute:~$  maas admin rack-controllers read | grep hostname | cut -d '"' -f 4 
wintermute</textarea>
</p>

<p>
So this would mean I should be able to turn on DHCP like this:
</p>

<p>
<textarea cols="80" rows="2">
stormrider@wintermute:~$ maas admin vlan update 2 untagged dhcp_on=True primary_rack=wintermute 
{"dhcp_on": ["dhcp can only be turned on when a dynamic IP range is defined."]}</textarea>
</p>

<p>
Hmm. I need to define a dynamic IP range for this to work. Well, given that my virtual bridge is on 192.168.123.0/24, I think I'll just use that subnet, so let me choose, say, 192.168.123.190 to 192.168.123.253:
</p>

<p>
<textarea cols="80" rows="1">
stormrider@wintermute:~$  maas admin ipranges create type=dynamic start_ip=192.168.123.190 end_ip=192.168.123.253 </textarea>
</p>

<p>
The result of this command is:
</p>

<p>
<textarea cols="80" rows="47">
Success.
Machine-readable output follows:
{
    "subnet": {
        "name": "192.168.123.0/24",
        "description": "",
        "vlan": {
            "vid": 0,
            "mtu": 1500,
            "dhcp_on": false,
            "external_dhcp": null,
            "relay_vlan": null,
            "fabric": "fabric-2",
            "primary_rack": null,
            "name": "untagged",
            "id": 5003,
            "space": "undefined",
            "secondary_rack": null,
            "fabric_id": 2,
            "resource_uri": "/MAAS/api/2.0/vlans/5003/"
        },
        "cidr": "192.168.123.0/24",
        "rdns_mode": 2,
        "gateway_ip": null,
        "dns_servers": [],
        "allow_dns": true,
        "allow_proxy": true,
        "active_discovery": false,
        "managed": true,
        "id": 4,
        "space": "undefined",
        "resource_uri": "/MAAS/api/2.0/subnets/4/"
    },
    "type": "dynamic",
    "start_ip": "192.168.123.190",
    "end_ip": "192.168.123.253",
    "user": {
        "is_superuser": true,
        "username": "admin",
        "email": "admin@admin.com",
        "is_local": true,
        "resource_uri": "/MAAS/api/2.0/users/admin/"
    },
    "comment": "",
    "id": 1,
    "resource_uri": "/MAAS/api/2.0/ipranges/1/"
}</textarea>
</p>

<p>
Okay, now let's try that DHCP switch-on one more time:
</p>

<p>
<textarea cols="80" rows="1">
stormrider@wintermute:~$  maas admin vlan update 2 untagged dhcp_on=True primary_rack=wintermute </textarea>
</p>

<p>
Now I get something more like I'd like:
</p>

<p>
<textarea cols="80" rows="17">
Success.
Machine-readable output follows:
{
    "vid": 0,
    "mtu": 1500,
    "dhcp_on": true,
    "external_dhcp": null,
    "relay_vlan": null,
    "fabric": "fabric-2",
    "space": "undefined",
    "primary_rack": "8dwnne",
    "secondary_rack": null,
    "name": "untagged",
    "fabric_id": 2,
    "id": 5003,
    "resource_uri": "/MAAS/api/2.0/vlans/5003/"
}</textarea>
</p>

<p>
It says success, and when I look at the UI? Yes, indeed, DHCP is enabled.
</p>
</div>
</div>

<div id="outline-container-org7b250ea" class="outline-2">
<h2 id="org7b250ea">Commissioning machines</h2>
<div class="outline-text-2" id="text-org7b250ea">
<p>
In order to deploy machines, I've got to create some, plain and simple, and then commission them. Normally, I'd do that with the UI, but for this exercise, I'm going to attempt it with the CLI.
</p>

<p>
<textarea cols="80" rows="185">
stormrider@wintermute:~$  maas admin machines create
  &gt; architecture=amd64
  &gt; mac_addresses=52:54:00:15:36:f2
  &gt; power_type=virsh
  &gt; power_parameters_power_id=f677a842-571c-4e65-adc9-11e2cf92d363
  &gt; power_parameters_power_address=qemu+ssh://stormrider@192.168.123.1/system
  &gt; power_parameters_power_pass=xxxxxxxx

Success.
Machine-readable output follows:
{
    "storage": 0.0,
    "tag_names": [],
    "special_filesystems": [],
    "memory": 0,
    "boot_disk": null,
    "virtualblockdevice_set": [],
    "hardware_info": {
        "system_vendor": "Unknown",
        "system_product": "Unknown",
        "system_family": "Unknown",
        "system_version": "Unknown",
        "system_sku": "Unknown",
        "system_serial": "Unknown",
        "cpu_model": "Unknown",
        "mainboard_vendor": "Unknown",
        "mainboard_product": "Unknown",
        "mainboard_serial": "Unknown",
        "mainboard_version": "Unknown",
        "mainboard_firmware_vendor": "Unknown",
        "mainboard_firmware_date": "Unknown",
        "mainboard_firmware_version": "Unknown",
        "chassis_vendor": "Unknown",
        "chassis_type": "Unknown",
        "chassis_serial": "Unknown",
        "chassis_version": "Unknown"
    },
    "address_ttl": null,
    "memory_test_status": -1,
    "other_test_status_name": "Unknown",
    "osystem": "",
    "status_message": "Commissioning",
    "netboot": true,
    "physicalblockdevice_set": [],
    "node_type": 0,
    "cpu_test_status": -1,
    "memory_test_status_name": "Unknown",
    "bcaches": [],
    "storage_test_status": 0,
    "system_id": "bhxws3",
    "status": 1,
    "commissioning_status": 0,
    "power_type": "virsh",
    "locked": false,
    "numanode_set": [
        {
            "index": 0,
            "memory": 0,
            "cores": []
        }
    ],
    "bios_boot_method": null,
    "fqdn": "ace-swan.maas",
    "node_type_name": "Machine",
    "hostname": "ace-swan",
    "volume_groups": [],
    "testing_status": 0,
    "network_test_status": -1,
    "other_test_status": -1,
    "interface_test_status": -1,
    "hwe_kernel": null,
    "blockdevice_set": [],
    "testing_status_name": "Pending",
    "power_state": "unknown",
    "min_hwe_kernel": "",
    "owner": "admin",
    "distro_series": "",
    "storage_test_status_name": "Pending",
    "cpu_speed": 0,
    "swap_size": null,
    "cpu_test_status_name": "Unknown",
    "hardware_uuid": null,
    "architecture": "amd64/generic",
    "pool": {
        "name": "default",
        "description": "Default pool",
        "id": 0,
        "resource_uri": "/MAAS/api/2.0/resourcepool/0/"
    },
    "cache_sets": [],
    "pod": null,
    "iscsiblockdevice_set": [],
    "disable_ipv4": false,
    "status_action": "",
    "boot_interface": {
        "name": "eth0",
        "id": 10,
        "product": null,
        "system_id": "bhxws3",
        "effective_mtu": 1500,
        "children": [],
        "link_connected": true,
        "enabled": true,
        "interface_speed": 0,
        "numa_node": 0,
        "firmware_version": null,
        "parents": [],
        "discovered": null,
        "params": "",
        "links": [],
        "sriov_max_vf": 0,
        "tags": [],
        "type": "physical",
        "vlan": null,
        "vendor": null,
        "link_speed": 0,
        "mac_address": "52:54:00:15:36:f2",
        "resource_uri": "/MAAS/api/2.0/nodes/bhxws3/interfaces/10/"
    },
    "cpu_count": 0,
    "domain": {
        "authoritative": true,
        "ttl": null,
        "resource_record_count": 0,
        "name": "maas",
        "is_default": true,
        "id": 0,
        "resource_uri": "/MAAS/api/2.0/domains/0/"
    },
    "current_testing_result_id": 7,
    "default_gateways": {
        "ipv4": {
            "gateway_ip": null,
            "link_id": null
        },
        "ipv6": {
            "gateway_ip": null,
            "link_id": null
        }
    },
    "interface_set": [
        {
            "name": "eth0",
            "id": 10,
            "product": null,
            "system_id": "bhxws3",
            "effective_mtu": 1500,
            "children": [],
            "link_connected": true,
            "enabled": true,
            "interface_speed": 0,
            "numa_node": 0,
            "firmware_version": null,
            "parents": [],
            "discovered": null,
            "params": "",
            "links": [],
            "sriov_max_vf": 0,
            "tags": [],
            "type": "physical",
            "vlan": null,
            "vendor": null,
            "link_speed": 0,
            "mac_address": "52:54:00:15:36:f2",
            "resource_uri": "/MAAS/api/2.0/nodes/bhxws3/interfaces/10/"
        }
    ],
    "status_name": "Commissioning",
    "commissioning_status_name": "Pending",
    "owner_data": {},
    "ip_addresses": [],
    "raids": [],
    "network_test_status_name": "Unknown",
    "description": "",
    "current_commissioning_result_id": 6,
    "interface_test_status_name": "Unknown",
    "current_installation_result_id": null,
    "zone": {
        "name": "default",
        "description": "",
        "id": 1,
        "resource_uri": "/MAAS/api/2.0/zones/default/"
    },
    "resource_uri": "/MAAS/api/2.0/machines/bhxws3/"
}</textarea>
</p>

<p>
And just like that, it's already commissioning, just as if I'd created it from the UI. A lot of parameters there are a little hard to discover: They may be somewhere in the documentation, or perhaps they're buried in one of the "read" outputs. I used the help and a couple of other commands to discover the "powerpass" parameter, for example, though I later found it somewhere else in the documentation. Doc is always a work in progress, I guess.
Commissioning by CLI
</p>

<p>
So now I have a machine in the "Ready" state, but I'd like to get familiar with commanding MAAS to commission it via the CLI. All I really need for that is the system ID, which is the last parameter in the "resourceuri" above. But just for grins, let's go ahead and retrieve the system ID using the CLI. There's only one, so I don't have to worry about any other cross-referencing on this machine:
</p>

<p>
<textarea cols="80" rows="3">
stormrider@wintermute:~$  maas admin machines read | jq '.[] | .hostname, .system_id' 
"ace-swan"
"bhxws3"</textarea>
</p>

<p>
Okay, now I can use that system ID to commission the machine via the CLI:
</p>

<p>
<textarea cols="80" rows="289">
stormrider@wintermute:~$  maas admin machine commission bhxws3 

Success.
Machine-readable output follows:
{
    "storage_test_status_name": "Pending",
    "bcaches": [],
    "cpu_count": 1,
    "interface_set": [
        {
            "params": "",
            "numa_node": 0,
            "tags": [],
            "id": 10,
            "mac_address": "52:54:00:15:36:f2",
            "vendor": "Red Hat, Inc.",
            "children": [],
            "effective_mtu": 1500,
            "discovered": [],
            "links": [],
            "link_speed": 0,
            "link_connected": true,
            "system_id": "bhxws3",
            "enabled": true,
            "interface_speed": 0,
            "firmware_version": null,
            "name": "ens3",
            "sriov_max_vf": 0,
            "product": null,
            "vlan": {
                "vid": 0,
                "mtu": 1500,
                "dhcp_on": true,
                "external_dhcp": null,
                "relay_vlan": null,
                "fabric": "fabric-2",
                "primary_rack": "8dwnne",
                "name": "untagged",
                "id": 5003,
                "space": "undefined",
                "secondary_rack": null,
                "fabric_id": 2,
                "resource_uri": "/MAAS/api/2.0/vlans/5003/"
            },
            "parents": [],
            "type": "physical",
            "resource_uri": "/MAAS/api/2.0/nodes/bhxws3/interfaces/10/"
        }
    ],
    "network_test_status_name": "Unknown",
    "numanode_set": [
        {
            "index": 0,
            "memory": 985,
            "cores": [
                0
            ]
        }
    ],
    "locked": false,
    "hardware_uuid": "F677A842-571C-4E65-ADC9-11E2CF92D363",
    "default_gateways": {
        "ipv4": {
            "gateway_ip": null,
            "link_id": null
        },
        "ipv6": {
            "gateway_ip": null,
            "link_id": null
        }
    },
    "status_action": "",
    "status_message": "Commissioning",
    "cpu_test_status_name": "Unknown",
    "memory_test_status": -1,
    "virtualblockdevice_set": [],
    "pool": {
        "name": "default",
        "description": "Default pool",
        "id": 0,
        "resource_uri": "/MAAS/api/2.0/resourcepool/0/"
    },
    "current_testing_result_id": 9,
    "current_installation_result_id": null,
    "netboot": true,
    "description": "",
    "special_filesystems": [],
    "testing_status": 0,
    "memory": 1024,
    "current_commissioning_result_id": 8,
    "storage": 5368.70912,
    "commissioning_status": 0,
    "cpu_test_status": -1,
    "tag_names": [
        "virtual"
    ],
    "memory_test_status_name": "Unknown",
    "swap_size": null,
    "status_name": "Commissioning",
    "other_test_status": -1,
    "pod": null,
    "storage_test_status": 0,
    "blockdevice_set": [
        {
            "id_path": "/dev/disk/by-id/ata-QEMU_HARDDISK_QM00001",
            "size": 5368709120,
            "block_size": 512,
            "tags": [
                "ssd"
            ],
            "serial": "QM00001",
            "uuid": null,
            "numa_node": 0,
            "available_size": 5368709120,
            "id": 3,
            "partition_table_type": null,
            "model": "QEMU HARDDISK",
            "path": "/dev/disk/by-dname/sda",
            "storage_pool": null,
            "used_for": "Unused",
            "filesystem": null,
            "system_id": "bhxws3",
            "used_size": 0,
            "partitions": [],
            "name": "sda",
            "type": "physical",
            "resource_uri": "/MAAS/api/2.0/nodes/bhxws3/blockdevices/3/"
        }
    ],
    "other_test_status_name": "Unknown",
    "distro_series": "",
    "testing_status_name": "Pending",
    "ip_addresses": [],
    "address_ttl": null,
    "system_id": "bhxws3",
    "physicalblockdevice_set": [
        {
            "firmware_version": "2.5+",
            "serial": "QM00001",
            "uuid": null,
            "numa_node": 0,
            "available_size": 5368709120,
            "size": 5368709120,
            "tags": [
                "ssd"
            ],
            "id": 3,
            "partition_table_type": null,
            "id_path": "/dev/disk/by-id/ata-QEMU_HARDDISK_QM00001",
            "model": "QEMU HARDDISK",
            "path": "/dev/disk/by-dname/sda",
            "storage_pool": null,
            "used_for": "Unused",
            "filesystem": null,
            "system_id": "bhxws3",
            "used_size": 0,
            "partitions": [],
            "name": "sda",
            "block_size": 512,
            "type": "physical",
            "resource_uri": "/MAAS/api/2.0/nodes/bhxws3/blockdevices/3/"
        }
    ],
    "fqdn": "ace-swan.maas",
    "osystem": "",
    "domain": {
        "authoritative": true,
        "ttl": null,
        "resource_record_count": 0,
        "name": "maas",
        "id": 0,
        "is_default": true,
        "resource_uri": "/MAAS/api/2.0/domains/0/"
    },
    "boot_interface": {
        "params": "",
        "numa_node": 0,
        "tags": [],
        "id": 10,
        "mac_address": "52:54:00:15:36:f2",
        "vendor": "Red Hat, Inc.",
        "children": [],
        "effective_mtu": 1500,
        "discovered": [],
        "links": [],
        "link_speed": 0,
        "link_connected": true,
        "system_id": "bhxws3",
        "enabled": true,
        "interface_speed": 0,
        "firmware_version": null,
        "name": "ens3",
        "sriov_max_vf": 0,
        "product": null,
        "vlan": {
            "vid": 0,
            "mtu": 1500,
            "dhcp_on": true,
            "external_dhcp": null,
            "relay_vlan": null,
            "fabric": "fabric-2",
            "primary_rack": "8dwnne",
            "name": "untagged",
            "id": 5003,
            "space": "undefined",
            "secondary_rack": null,
            "fabric_id": 2,
            "resource_uri": "/MAAS/api/2.0/vlans/5003/"
        },
        "parents": [],
        "type": "physical",
        "resource_uri": "/MAAS/api/2.0/nodes/bhxws3/interfaces/10/"
    },
    "hostname": "ace-swan",
    "network_test_status": -1,
    "min_hwe_kernel": "",
    "power_state": "off",
    "interface_test_status_name": "Unknown",
    "owner_data": {},
    "volume_groups": [],
    "power_type": "virsh",
    "node_type": 0,
    "owner": "admin",
    "cache_sets": [],
    "architecture": "amd64/generic",
    "hwe_kernel": null,
    "zone": {
        "name": "default",
        "description": "",
        "id": 1,
        "resource_uri": "/MAAS/api/2.0/zones/default/"
    },
    "disable_ipv4": false,
    "boot_disk": {
        "firmware_version": "2.5+",
        "serial": "QM00001",
        "uuid": null,
        "numa_node": 0,
        "available_size": 5368709120,
        "size": 5368709120,
        "tags": [
            "ssd"
        ],
        "id": 3,
        "partition_table_type": null,
        "id_path": "/dev/disk/by-id/ata-QEMU_HARDDISK_QM00001",
        "model": "QEMU HARDDISK",
        "path": "/dev/disk/by-dname/sda",
        "storage_pool": null,
        "used_for": "Unused",
        "filesystem": null,
        "system_id": "bhxws3",
        "used_size": 0,
        "partitions": [],
        "name": "sda",
        "block_size": 512,
        "type": "physical",
        "resource_uri": "/MAAS/api/2.0/nodes/bhxws3/blockdevices/3/"
    },
    "status": 1,
    "iscsiblockdevice_set": [],
    "raids": [],
    "node_type_name": "Machine",
    "hardware_info": {
        "system_vendor": "QEMU",
        "system_product": "Standard PC (i440FX + PIIX, 1996)",
        "system_family": "Unknown",
        "system_version": "pc-i440fx-focal",
        "system_sku": "Unknown",
        "system_serial": "Unknown",
        "cpu_model": "Intel Core Processor (Skylake, IBRS)",
        "mainboard_vendor": "Unknown",
        "mainboard_product": "Unknown",
        "mainboard_serial": "Unknown",
        "mainboard_version": "Unknown",
        "mainboard_firmware_vendor": "SeaBIOS",
        "mainboard_firmware_date": "04/01/2014",
        "mainboard_firmware_version": "1.13.0-1ubuntu1",
        "chassis_vendor": "QEMU",
        "chassis_type": "Other",
        "chassis_serial": "Unknown",
        "chassis_version": "pc-i440fx-focal"
    },
    "commissioning_status_name": "Pending",
    "bios_boot_method": "pxe",
    "interface_test_status": -1,
    "cpu_speed": 0,
    "resource_uri": "/MAAS/api/2.0/machines/bhxws3/"
}</textarea>
</p>

<p>
And that's it, it's that easy. It takes a minute to get all the parameters together to create a new machine, but it doesn't seem that difficult to me. 
</p>
</div>
</div>

<div id="outline-container-orgba84949" class="outline-2">
<h2 id="orgba84949">Deploying machines</h2>
<div class="outline-text-2" id="text-orgba84949">
<p>
I guess now it's time to acquire and deploy my commissioned machine.
</p>
</div>

<div id="outline-container-org57bb4f2" class="outline-3">
<h3 id="org57bb4f2">Acquiring a machine using the CLI</h3>
<div class="outline-text-3" id="text-org57bb4f2">
<p>
When it's finished commissioning, I can acquire a machine like this:
</p>

<p>
<textarea cols="80" rows="493">
stormrider@wintermute:~$ maas admin machines allocate system_id=bhxws3

Success.
Machine-readable output follows:
{
    "raids": [],
    "zone": {
        "name": "default",
        "description": "",
        "id": 1,
        "resource_uri": "/MAAS/api/2.0/zones/default/"
    },
    "current_commissioning_result_id": 8,
    "storage_test_status": 2,
    "current_testing_result_id": 9,
    "bcaches": [],
    "ip_addresses": [
        "192.168.123.190"
    ],
    "pool": {
        "name": "default",
        "description": "Default pool",
        "id": 0,
        "resource_uri": "/MAAS/api/2.0/resourcepool/0/"
    },
    "physicalblockdevice_set": [
        {
            "firmware_version": "2.5+",
            "id_path": "/dev/disk/by-id/ata-QEMU_HARDDISK_QM00001",
            "system_id": "bhxws3",
            "partition_table_type": "GPT",
            "type": "physical",
            "block_size": 512,
            "id": 3,
            "numa_node": 0,
            "partitions": [
                {
                    "uuid": "8aa1164c-8a91-41d7-92e3-c411634355bb",
                    "size": 5360320512,
                    "bootable": false,
                    "tags": [],
                    "id": 3,
                    "used_for": "ext4 formatted filesystem mounted at /",
                    "device_id": 3,
                    "system_id": "bhxws3",
                    "path": "/dev/disk/by-dname/sda-part2",
                    "type": "partition",
                    "filesystem": {
                        "fstype": "ext4",
                        "label": "root",
                        "uuid": "68487852-7e38-4605-a84e-d787532fd443",
                        "mount_point": "/",
                        "mount_options": null
                    },
                    "resource_uri": "/MAAS/api/2.0/nodes/bhxws3/blockdevices/3/partition/3"
                }
            ],
            "filesystem": null,
            "available_size": 0,
            "size": 5368709120,
            "storage_pool": null,
            "model": "QEMU HARDDISK",
            "used_size": 5366611968,
            "tags": [
                "ssd"
            ],
            "used_for": "GPT partitioned with 1 partition",
            "uuid": null,
            "name": "sda",
            "path": "/dev/disk/by-dname/sda",
            "serial": "QM00001",
            "resource_uri": "/MAAS/api/2.0/nodes/bhxws3/blockdevices/3/"
        }
    ],
    "swap_size": null,
    "storage": 5368.70912,
    "node_type_name": "Machine",
    "system_id": "bhxws3",
    "owner_data": {},
    "special_filesystems": [],
    "tag_names": [
        "virtual"
    ],
    "cpu_test_status_name": "Unknown",
    "locked": false,
    "cpu_count": 1,
    "volume_groups": [],
    "storage_test_status_name": "Passed",
    "hardware_info": {
        "system_vendor": "QEMU",
        "system_product": "Standard PC (i440FX + PIIX, 1996)",
        "system_family": "Unknown",
        "system_version": "pc-i440fx-focal",
        "system_sku": "Unknown",
        "system_serial": "Unknown",
        "cpu_model": "Intel Core Processor (Skylake, IBRS)",
        "mainboard_vendor": "Unknown",
        "mainboard_product": "Unknown",
        "mainboard_serial": "Unknown",
        "mainboard_version": "Unknown",
        "mainboard_firmware_vendor": "SeaBIOS",
        "mainboard_firmware_date": "04/01/2014",
        "mainboard_firmware_version": "1.13.0-1ubuntu1",
        "chassis_vendor": "QEMU",
        "chassis_type": "Other",
        "chassis_serial": "Unknown",
        "chassis_version": "pc-i440fx-focal"
    },
    "node_type": 0,
    "other_test_status": -1,
    "hostname": "ace-swan",
    "interface_test_status": -1,
    "boot_interface": {
        "link_speed": 0,
        "params": "",
        "vendor": "Red Hat, Inc.",
        "firmware_version": null,
        "system_id": "bhxws3",
        "enabled": true,
        "type": "physical",
        "links": [
            {
                "id": 15,
                "mode": "auto",
                "subnet": {
                    "name": "192.168.123.0/24",
                    "description": "",
                    "vlan": {
                        "vid": 0,
                        "mtu": 1500,
                        "dhcp_on": true,
                        "external_dhcp": null,
                        "relay_vlan": null,
                        "fabric": "fabric-2",
                        "id": 5003,
                        "secondary_rack": null,
                        "primary_rack": "8dwnne",
                        "name": "untagged",
                        "fabric_id": 2,
                        "space": "undefined",
                        "resource_uri": "/MAAS/api/2.0/vlans/5003/"
                    },
                    "cidr": "192.168.123.0/24",
                    "rdns_mode": 2,
                    "gateway_ip": null,
                    "dns_servers": [],
                    "allow_dns": true,
                    "allow_proxy": true,
                    "active_discovery": false,
                    "managed": true,
                    "id": 4,
                    "space": "undefined",
                    "resource_uri": "/MAAS/api/2.0/subnets/4/"
                }
            }
        ],
        "id": 10,
        "discovered": [
            {
                "subnet": {
                    "name": "192.168.123.0/24",
                    "description": "",
                    "vlan": {
                        "vid": 0,
                        "mtu": 1500,
                        "dhcp_on": true,
                        "external_dhcp": null,
                        "relay_vlan": null,
                        "fabric": "fabric-2",
                        "id": 5003,
                        "secondary_rack": null,
                        "primary_rack": "8dwnne",
                        "name": "untagged",
                        "fabric_id": 2,
                        "space": "undefined",
                        "resource_uri": "/MAAS/api/2.0/vlans/5003/"
                    },
                    "cidr": "192.168.123.0/24",
                    "rdns_mode": 2,
                    "gateway_ip": null,
                    "dns_servers": [],
                    "allow_dns": true,
                    "allow_proxy": true,
                    "active_discovery": false,
                    "managed": true,
                    "id": 4,
                    "space": "undefined",
                    "resource_uri": "/MAAS/api/2.0/subnets/4/"
                },
                "ip_address": "192.168.123.190"
            }
        ],
        "numa_node": 0,
        "children": [],
        "parents": [],
        "link_connected": true,
        "effective_mtu": 1500,
        "tags": [],
        "sriov_max_vf": 0,
        "interface_speed": 0,
        "name": "ens3",
        "mac_address": "52:54:00:15:36:f2",
        "product": null,
        "vlan": {
            "vid": 0,
            "mtu": 1500,
            "dhcp_on": true,
            "external_dhcp": null,
            "relay_vlan": null,
            "fabric": "fabric-2",
            "id": 5003,
            "secondary_rack": null,
            "primary_rack": "8dwnne",
            "name": "untagged",
            "fabric_id": 2,
            "space": "undefined",
            "resource_uri": "/MAAS/api/2.0/vlans/5003/"
        },
        "resource_uri": "/MAAS/api/2.0/nodes/bhxws3/interfaces/10/"
    },
    "memory": 1024,
    "memory_test_status_name": "Unknown",
    "default_gateways": {
        "ipv4": {
            "gateway_ip": null,
            "link_id": null
        },
        "ipv6": {
            "gateway_ip": null,
            "link_id": null
        }
    },
    "blockdevice_set": [
        {
            "id_path": "/dev/disk/by-id/ata-QEMU_HARDDISK_QM00001",
            "size": 5368709120,
            "block_size": 512,
            "tags": [
                "ssd"
            ],
            "system_id": "bhxws3",
            "partition_table_type": "GPT",
            "type": "physical",
            "id": 3,
            "numa_node": 0,
            "partitions": [
                {
                    "uuid": "8aa1164c-8a91-41d7-92e3-c411634355bb",
                    "size": 5360320512,
                    "bootable": false,
                    "tags": [],
                    "id": 3,
                    "used_for": "ext4 formatted filesystem mounted at /",
                    "device_id": 3,
                    "system_id": "bhxws3",
                    "path": "/dev/disk/by-dname/sda-part2",
                    "type": "partition",
                    "filesystem": {
                        "fstype": "ext4",
                        "label": "root",
                        "uuid": "68487852-7e38-4605-a84e-d787532fd443",
                        "mount_point": "/",
                        "mount_options": null
                    },
                    "resource_uri": "/MAAS/api/2.0/nodes/bhxws3/blockdevices/3/partition/3"
                }
            ],
            "filesystem": null,
            "available_size": 0,
            "storage_pool": null,
            "model": "QEMU HARDDISK",
            "used_size": 5366611968,
            "used_for": "GPT partitioned with 1 partition",
            "uuid": null,
            "name": "sda",
            "path": "/dev/disk/by-dname/sda",
            "serial": "QM00001",
            "resource_uri": "/MAAS/api/2.0/nodes/bhxws3/blockdevices/3/"
        }
    ],
    "interface_set": [
        {
            "link_speed": 0,
            "params": "",
            "vendor": "Red Hat, Inc.",
            "firmware_version": null,
            "system_id": "bhxws3",
            "enabled": true,
            "type": "physical",
            "links": [
                {
                    "id": 15,
                    "mode": "auto",
                    "subnet": {
                        "name": "192.168.123.0/24",
                        "description": "",
                        "vlan": {
                            "vid": 0,
                            "mtu": 1500,
                            "dhcp_on": true,
                            "external_dhcp": null,
                            "relay_vlan": null,
                            "fabric": "fabric-2",
                            "id": 5003,
                            "secondary_rack": null,
                            "primary_rack": "8dwnne",
                            "name": "untagged",
                            "fabric_id": 2,
                            "space": "undefined",
                            "resource_uri": "/MAAS/api/2.0/vlans/5003/"
                        },
                        "cidr": "192.168.123.0/24",
                        "rdns_mode": 2,
                        "gateway_ip": null,
                        "dns_servers": [],
                        "allow_dns": true,
                        "allow_proxy": true,
                        "active_discovery": false,
                        "managed": true,
                        "id": 4,
                        "space": "undefined",
                        "resource_uri": "/MAAS/api/2.0/subnets/4/"
                    }
                }
            ],
            "id": 10,
            "discovered": [
                {
                    "subnet": {
                        "name": "192.168.123.0/24",
                        "description": "",
                        "vlan": {
                            "vid": 0,
                            "mtu": 1500,
                            "dhcp_on": true,
                            "external_dhcp": null,
                            "relay_vlan": null,
                            "fabric": "fabric-2",
                            "id": 5003,
                            "secondary_rack": null,
                            "primary_rack": "8dwnne",
                            "name": "untagged",
                            "fabric_id": 2,
                            "space": "undefined",
                            "resource_uri": "/MAAS/api/2.0/vlans/5003/"
                        },
                        "cidr": "192.168.123.0/24",
                        "rdns_mode": 2,
                        "gateway_ip": null,
                        "dns_servers": [],
                        "allow_dns": true,
                        "allow_proxy": true,
                        "active_discovery": false,
                        "managed": true,
                        "id": 4,
                        "space": "undefined",
                        "resource_uri": "/MAAS/api/2.0/subnets/4/"
                    },
                    "ip_address": "192.168.123.190"
                }
            ],
            "numa_node": 0,
            "children": [],
            "parents": [],
            "link_connected": true,
            "effective_mtu": 1500,
            "tags": [],
            "sriov_max_vf": 0,
            "interface_speed": 0,
            "name": "ens3",
            "mac_address": "52:54:00:15:36:f2",
            "product": null,
            "vlan": {
                "vid": 0,
                "mtu": 1500,
                "dhcp_on": true,
                "external_dhcp": null,
                "relay_vlan": null,
                "fabric": "fabric-2",
                "id": 5003,
                "secondary_rack": null,
                "primary_rack": "8dwnne",
                "name": "untagged",
                "fabric_id": 2,
                "space": "undefined",
                "resource_uri": "/MAAS/api/2.0/vlans/5003/"
            },
            "resource_uri": "/MAAS/api/2.0/nodes/bhxws3/interfaces/10/"
        }
    ],
    "numanode_set": [
        {
            "index": 0,
            "memory": 985,
            "cores": [
                0
            ]
        }
    ],
    "min_hwe_kernel": "",
    "memory_test_status": -1,
    "power_type": "virsh",
    "power_state": "off",
    "status": 10,
    "testing_status_name": "Passed",
    "interface_test_status_name": "Unknown",
    "cache_sets": [],
    "constraints_by_type": {},
    "domain": {
        "authoritative": true,
        "ttl": null,
        "id": 0,
        "resource_record_count": 0,
        "name": "maas",
        "is_default": true,
        "resource_uri": "/MAAS/api/2.0/domains/0/"
    },
    "network_test_status": -1,
    "current_installation_result_id": null,
    "bios_boot_method": "pxe",
    "status_name": "Allocated",
    "address_ttl": null,
    "fqdn": "ace-swan.maas",
    "cpu_speed": 0,
    "hwe_kernel": null,
    "description": "",
    "commissioning_status_name": "Passed",
    "pod": null,
    "network_test_status_name": "Unknown",
    "hardware_uuid": "F677A842-571C-4E65-ADC9-11E2CF92D363",
    "commissioning_status": 2,
    "status_message": "Ready",
    "owner": "admin",
    "distro_series": "",
    "status_action": "",
    "testing_status": 2,
    "cpu_test_status": -1,
    "architecture": "amd64/generic",
    "netboot": true,
    "iscsiblockdevice_set": [],
    "disable_ipv4": false,
    "virtualblockdevice_set": [],
    "osystem": "",
    "boot_disk": {
        "firmware_version": "2.5+",
        "id_path": "/dev/disk/by-id/ata-QEMU_HARDDISK_QM00001",
        "system_id": "bhxws3",
        "partition_table_type": "GPT",
        "type": "physical",
        "block_size": 512,
        "id": 3,
        "numa_node": 0,
        "partitions": [
            {
                "uuid": "8aa1164c-8a91-41d7-92e3-c411634355bb",
                "size": 5360320512,
                "bootable": false,
                "tags": [],
                "id": 3,
                "used_for": "ext4 formatted filesystem mounted at /",
                "device_id": 3,
                "system_id": "bhxws3",
                "path": "/dev/disk/by-dname/sda-part2",
                "type": "partition",
                "filesystem": {
                    "fstype": "ext4",
                    "label": "root",
                    "uuid": "68487852-7e38-4605-a84e-d787532fd443",
                    "mount_point": "/",
                    "mount_options": null
                },
                "resource_uri": "/MAAS/api/2.0/nodes/bhxws3/blockdevices/3/partition/3"
            }
        ],
        "filesystem": null,
        "available_size": 0,
        "size": 5368709120,
        "storage_pool": null,
        "model": "QEMU HARDDISK",
        "used_size": 5366611968,
        "tags": [
            "ssd"
        ],
        "used_for": "GPT partitioned with 1 partition",
        "uuid": null,
        "name": "sda",
        "path": "/dev/disk/by-dname/sda",
        "serial": "QM00001",
        "resource_uri": "/MAAS/api/2.0/nodes/bhxws3/blockdevices/3/"
    },
    "other_test_status_name": "Unknown",
    "resource_uri": "/MAAS/api/2.0/machines/bhxws3/"
}</textarea>
</p>
</div>
</div>

<div id="outline-container-orgbd9b32b" class="outline-3">
<h3 id="orgbd9b32b">Deploying a machine with the CLI</h3>
<div class="outline-text-3" id="text-orgbd9b32b">
<p>
Having once acquired the machine, which basically gives my username control, I can deploy the machine this way:
</p>

<p>
<textarea cols="80" rows="492">
stormrider@wintermute:~$  maas admin machine deploy bhxws3 

Success.
Machine-readable output follows:
{
    "architecture": "amd64/generic",
    "cpu_speed": 0,
    "tag_names": [
        "virtual"
    ],
    "boot_interface": {
        "mac_address": "52:54:00:15:36:f2",
        "links": [
            {
                "id": 15,
                "mode": "auto",
                "subnet": {
                    "name": "192.168.123.0/24",
                    "description": "",
                    "vlan": {
                        "vid": 0,
                        "mtu": 1500,
                        "dhcp_on": true,
                        "external_dhcp": null,
                        "relay_vlan": null,
                        "fabric_id": 2,
                        "id": 5003,
                        "fabric": "fabric-2",
                        "secondary_rack": null,
                        "name": "untagged",
                        "space": "undefined",
                        "primary_rack": "8dwnne",
                        "resource_uri": "/MAAS/api/2.0/vlans/5003/"
                    },
                    "cidr": "192.168.123.0/24",
                    "rdns_mode": 2,
                    "gateway_ip": null,
                    "dns_servers": [],
                    "allow_dns": true,
                    "allow_proxy": true,
                    "active_discovery": false,
                    "managed": true,
                    "id": 4,
                    "space": "undefined",
                    "resource_uri": "/MAAS/api/2.0/subnets/4/"
                }
            }
        ],
        "numa_node": 0,
        "enabled": true,
        "params": "",
        "firmware_version": null,
        "sriov_max_vf": 0,
        "type": "physical",
        "children": [],
        "vendor": "Red Hat, Inc.",
        "system_id": "bhxws3",
        "parents": [],
        "vlan": {
            "vid": 0,
            "mtu": 1500,
            "dhcp_on": true,
            "external_dhcp": null,
            "relay_vlan": null,
            "fabric_id": 2,
            "id": 5003,
            "fabric": "fabric-2",
            "secondary_rack": null,
            "name": "untagged",
            "space": "undefined",
            "primary_rack": "8dwnne",
            "resource_uri": "/MAAS/api/2.0/vlans/5003/"
        },
        "link_connected": true,
        "id": 10,
        "effective_mtu": 1500,
        "discovered": [
            {
                "subnet": {
                    "name": "192.168.123.0/24",
                    "description": "",
                    "vlan": {
                        "vid": 0,
                        "mtu": 1500,
                        "dhcp_on": true,
                        "external_dhcp": null,
                        "relay_vlan": null,
                        "fabric_id": 2,
                        "id": 5003,
                        "fabric": "fabric-2",
                        "secondary_rack": null,
                        "name": "untagged",
                        "space": "undefined",
                        "primary_rack": "8dwnne",
                        "resource_uri": "/MAAS/api/2.0/vlans/5003/"
                    },
                    "cidr": "192.168.123.0/24",
                    "rdns_mode": 2,
                    "gateway_ip": null,
                    "dns_servers": [],
                    "allow_dns": true,
                    "allow_proxy": true,
                    "active_discovery": false,
                    "managed": true,
                    "id": 4,
                    "space": "undefined",
                    "resource_uri": "/MAAS/api/2.0/subnets/4/"
                },
                "ip_address": "192.168.123.190"
            }
        ],
        "link_speed": 0,
        "name": "ens3",
        "product": null,
        "interface_speed": 0,
        "tags": [],
        "resource_uri": "/MAAS/api/2.0/nodes/bhxws3/interfaces/10/"
    },
    "ip_addresses": [
        "192.168.123.190"
    ],
    "testing_status_name": "Passed",
    "osystem": "ubuntu",
    "bcaches": [],
    "owner": "admin",
    "special_filesystems": [],
    "numanode_set": [
        {
            "index": 0,
            "memory": 985,
            "cores": [
                0
            ]
        }
    ],
    "node_type": 0,
    "cpu_test_status": -1,
    "storage_test_status_name": "Passed",
    "locked": false,
    "disable_ipv4": false,
    "status_message": "Deploying",
    "other_test_status_name": "Unknown",
    "interface_test_status_name": "Unknown",
    "status_name": "Deploying",
    "commissioning_status": 2,
    "hardware_uuid": "F677A842-571C-4E65-ADC9-11E2CF92D363",
    "fqdn": "ace-swan.maas",
    "min_hwe_kernel": "",
    "network_test_status": -1,
    "iscsiblockdevice_set": [],
    "current_testing_result_id": 9,
    "interface_test_status": -1,
    "status_action": "",
    "pool": {
        "name": "default",
        "description": "Default pool",
        "id": 0,
        "resource_uri": "/MAAS/api/2.0/resourcepool/0/"
    },
    "netboot": true,
    "distro_series": "bionic",
    "current_installation_result_id": 10,
    "memory_test_status_name": "Unknown",
    "cpu_count": 1,
    "hwe_kernel": "ga-18.04",
    "description": "",
    "current_commissioning_result_id": 8,
    "cpu_test_status_name": "Unknown",
    "storage_test_status": 2,
    "hardware_info": {
        "system_vendor": "QEMU",
        "system_product": "Standard PC (i440FX + PIIX, 1996)",
        "system_family": "Unknown",
        "system_version": "pc-i440fx-focal",
        "system_sku": "Unknown",
        "system_serial": "Unknown",
        "cpu_model": "Intel Core Processor (Skylake, IBRS)",
        "mainboard_vendor": "Unknown",
        "mainboard_product": "Unknown",
        "mainboard_serial": "Unknown",
        "mainboard_version": "Unknown",
        "mainboard_firmware_vendor": "SeaBIOS",
        "mainboard_firmware_date": "04/01/2014",
        "mainboard_firmware_version": "1.13.0-1ubuntu1",
        "chassis_vendor": "QEMU",
        "chassis_type": "Other",
        "chassis_serial": "Unknown",
        "chassis_version": "pc-i440fx-focal"
    },
    "bios_boot_method": "pxe",
    "storage": 5368.70912,
    "blockdevice_set": [
        {
            "id_path": "/dev/disk/by-id/ata-QEMU_HARDDISK_QM00001",
            "size": 5368709120,
            "block_size": 512,
            "tags": [
                "ssd"
            ],
            "numa_node": 0,
            "partition_table_type": "GPT",
            "storage_pool": null,
            "type": "physical",
            "filesystem": null,
            "model": "QEMU HARDDISK",
            "used_size": 5366611968,
            "serial": "QM00001",
            "system_id": "bhxws3",
            "uuid": null,
            "available_size": 0,
            "path": "/dev/disk/by-dname/sda",
            "id": 3,
            "name": "sda",
            "partitions": [
                {
                    "uuid": "8aa1164c-8a91-41d7-92e3-c411634355bb",
                    "size": 5360320512,
                    "bootable": false,
                    "tags": [],
                    "path": "/dev/disk/by-dname/sda-part2",
                    "device_id": 3,
                    "type": "partition",
                    "id": 3,
                    "system_id": "bhxws3",
                    "filesystem": {
                        "fstype": "ext4",
                        "label": "root",
                        "uuid": "68487852-7e38-4605-a84e-d787532fd443",
                        "mount_point": "/",
                        "mount_options": null
                    },
                    "used_for": "ext4 formatted filesystem mounted at /",
                    "resource_uri": "/MAAS/api/2.0/nodes/bhxws3/blockdevices/3/partition/3"
                }
            ],
            "used_for": "GPT partitioned with 1 partition",
            "resource_uri": "/MAAS/api/2.0/nodes/bhxws3/blockdevices/3/"
        }
    ],
    "system_id": "bhxws3",
    "boot_disk": {
        "firmware_version": "2.5+",
        "tags": [
            "ssd"
        ],
        "numa_node": 0,
        "partition_table_type": "GPT",
        "size": 5368709120,
        "storage_pool": null,
        "type": "physical",
        "block_size": 512,
        "filesystem": null,
        "model": "QEMU HARDDISK",
        "used_size": 5366611968,
        "serial": "QM00001",
        "system_id": "bhxws3",
        "uuid": null,
        "available_size": 0,
        "path": "/dev/disk/by-dname/sda",
        "id": 3,
        "id_path": "/dev/disk/by-id/ata-QEMU_HARDDISK_QM00001",
        "name": "sda",
        "partitions": [
            {
                "uuid": "8aa1164c-8a91-41d7-92e3-c411634355bb",
                "size": 5360320512,
                "bootable": false,
                "tags": [],
                "path": "/dev/disk/by-dname/sda-part2",
                "device_id": 3,
                "type": "partition",
                "id": 3,
                "system_id": "bhxws3",
                "filesystem": {
                    "fstype": "ext4",
                    "label": "root",
                    "uuid": "68487852-7e38-4605-a84e-d787532fd443",
                    "mount_point": "/",
                    "mount_options": null
                },
                "used_for": "ext4 formatted filesystem mounted at /",
                "resource_uri": "/MAAS/api/2.0/nodes/bhxws3/blockdevices/3/partition/3"
            }
        ],
        "used_for": "GPT partitioned with 1 partition",
        "resource_uri": "/MAAS/api/2.0/nodes/bhxws3/blockdevices/3/"
    },
    "default_gateways": {
        "ipv4": {
            "gateway_ip": null,
            "link_id": null
        },
        "ipv6": {
            "gateway_ip": null,
            "link_id": null
        }
    },
    "raids": [],
    "cache_sets": [],
    "domain": {
        "authoritative": true,
        "ttl": null,
        "is_default": true,
        "id": 0,
        "name": "maas",
        "resource_record_count": 0,
        "resource_uri": "/MAAS/api/2.0/domains/0/"
    },
    "hostname": "ace-swan",
    "virtualblockdevice_set": [],
    "memory": 1024,
    "owner_data": {},
    "zone": {
        "name": "default",
        "description": "",
        "id": 1,
        "resource_uri": "/MAAS/api/2.0/zones/default/"
    },
    "power_state": "off",
    "status": 9,
    "address_ttl": null,
    "other_test_status": -1,
    "volume_groups": [],
    "power_type": "virsh",
    "pod": null,
    "testing_status": 2,
    "physicalblockdevice_set": [
        {
            "firmware_version": "2.5+",
            "tags": [
                "ssd"
            ],
            "numa_node": 0,
            "partition_table_type": "GPT",
            "size": 5368709120,
            "storage_pool": null,
            "type": "physical",
            "block_size": 512,
            "filesystem": null,
            "model": "QEMU HARDDISK",
            "used_size": 5366611968,
            "serial": "QM00001",
            "system_id": "bhxws3",
            "uuid": null,
            "available_size": 0,
            "path": "/dev/disk/by-dname/sda",
            "id": 3,
            "id_path": "/dev/disk/by-id/ata-QEMU_HARDDISK_QM00001",
            "name": "sda",
            "partitions": [
                {
                    "uuid": "8aa1164c-8a91-41d7-92e3-c411634355bb",
                    "size": 5360320512,
                    "bootable": false,
                    "tags": [],
                    "path": "/dev/disk/by-dname/sda-part2",
                    "device_id": 3,
                    "type": "partition",
                    "id": 3,
                    "system_id": "bhxws3",
                    "filesystem": {
                        "fstype": "ext4",
                        "label": "root",
                        "uuid": "68487852-7e38-4605-a84e-d787532fd443",
                        "mount_point": "/",
                        "mount_options": null
                    },
                    "used_for": "ext4 formatted filesystem mounted at /",
                    "resource_uri": "/MAAS/api/2.0/nodes/bhxws3/blockdevices/3/partition/3"
                }
            ],
            "used_for": "GPT partitioned with 1 partition",
            "resource_uri": "/MAAS/api/2.0/nodes/bhxws3/blockdevices/3/"
        }
    ],
    "interface_set": [
        {
            "mac_address": "52:54:00:15:36:f2",
            "links": [
                {
                    "id": 15,
                    "mode": "auto",
                    "subnet": {
                        "name": "192.168.123.0/24",
                        "description": "",
                        "vlan": {
                            "vid": 0,
                            "mtu": 1500,
                            "dhcp_on": true,
                            "external_dhcp": null,
                            "relay_vlan": null,
                            "fabric_id": 2,
                            "id": 5003,
                            "fabric": "fabric-2",
                            "secondary_rack": null,
                            "name": "untagged",
                            "space": "undefined",
                            "primary_rack": "8dwnne",
                            "resource_uri": "/MAAS/api/2.0/vlans/5003/"
                        },
                        "cidr": "192.168.123.0/24",
                        "rdns_mode": 2,
                        "gateway_ip": null,
                        "dns_servers": [],
                        "allow_dns": true,
                        "allow_proxy": true,
                        "active_discovery": false,
                        "managed": true,
                        "id": 4,
                        "space": "undefined",
                        "resource_uri": "/MAAS/api/2.0/subnets/4/"
                    }
                }
            ],
            "numa_node": 0,
            "enabled": true,
            "params": "",
            "firmware_version": null,
            "sriov_max_vf": 0,
            "type": "physical",
            "children": [],
            "vendor": "Red Hat, Inc.",
            "system_id": "bhxws3",
            "parents": [],
            "vlan": {
                "vid": 0,
                "mtu": 1500,
                "dhcp_on": true,
                "external_dhcp": null,
                "relay_vlan": null,
                "fabric_id": 2,
                "id": 5003,
                "fabric": "fabric-2",
                "secondary_rack": null,
                "name": "untagged",
                "space": "undefined",
                "primary_rack": "8dwnne",
                "resource_uri": "/MAAS/api/2.0/vlans/5003/"
            },
            "link_connected": true,
            "id": 10,
            "effective_mtu": 1500,
            "discovered": [
                {
                    "subnet": {
                        "name": "192.168.123.0/24",
                        "description": "",
                        "vlan": {
                            "vid": 0,
                            "mtu": 1500,
                            "dhcp_on": true,
                            "external_dhcp": null,
                            "relay_vlan": null,
                            "fabric_id": 2,
                            "id": 5003,
                            "fabric": "fabric-2",
                            "secondary_rack": null,
                            "name": "untagged",
                            "space": "undefined",
                            "primary_rack": "8dwnne",
                            "resource_uri": "/MAAS/api/2.0/vlans/5003/"
                        },
                        "cidr": "192.168.123.0/24",
                        "rdns_mode": 2,
                        "gateway_ip": null,
                        "dns_servers": [],
                        "allow_dns": true,
                        "allow_proxy": true,
                        "active_discovery": false,
                        "managed": true,
                        "id": 4,
                        "space": "undefined",
                        "resource_uri": "/MAAS/api/2.0/subnets/4/"
                    },
                    "ip_address": "192.168.123.190"
                }
            ],
            "link_speed": 0,
            "name": "ens3",
            "product": null,
            "interface_speed": 0,
            "tags": [],
            "resource_uri": "/MAAS/api/2.0/nodes/bhxws3/interfaces/10/"
        }
    ],
    "node_type_name": "Machine",
    "commissioning_status_name": "Passed",
    "network_test_status_name": "Unknown",
    "memory_test_status": -1,
    "swap_size": null,
    "resource_uri": "/MAAS/api/2.0/machines/bhxws3/"
}</textarea>
</p>

<p>
Okay, done with that much. I have installed and configured MAAS, started DHCP, created a machine, commissioned it, acquired it, and deployed it without touching the UI.
</p>
</div>
</div>
</div>

<div id="outline-container-org07d11b0" class="outline-2">
<h2 id="org07d11b0">jq tricks</h2>
<div class="outline-text-2" id="text-org07d11b0">
<p>
It's very evident that the JSON output from the allocate and deploy commands was very lengthy for even one machine  so you can imagine how large a list of 10 or 12 machines might be. Traditional JSON output is both consistent and comprehensive, but sometimes hard for humans to process.
</p>

<p>
Enter jq, a command-line tool dedicated to filtering and formatting JSON output, so that you can more easily summarize data. For instance, consider a small MAAS install with 12 virtual machines. Six of these machines are lxd VMs, and six are libvirt VMs. Suppose I enter the MAAS CLI command to list all those machines:
</p>

<p>
<textarea cols="80" rows="1">
stormrider@wintermute:~$ maas admin machines read</textarea>
</p>

<p>
The listing would be many pages long, and likely very time-consuming to pick through. On the other hand, I can apply the jq command, a couple of other Ubuntu CLI commands, and just a little bit of finesse to get something conventional-looking:
</p>

<p>
<textarea cols="80" rows="6">
stormrider@wintermute:~$ maas admin machines read | jq -r '(["HOSTNAME","SYSID",
"POWER","STATUS","OWNER", "TAGS", "POOL","VLAN","FABRIC",
"SUBNET"] | (., map(length*"-"))),(.[] | [.hostname, .system_id, 
.power_state, .status_name, .owner // "-",.tag_names[0] // "-", 
.pool.name,.boot_interface.vlan.name,.boot_interface.vlan.fabric,
.boot_interface.links[0].subnet.name]) | @tsv' | column -t</textarea>
</p>

<p>
In fact, with this command,we can produce an useful and compact machine listing that serves 99% of my routine MAAS information needs:
</p>

<p>
<textarea cols="80" rows="14">
HOSTNAME      SYSID   POWER  STATUS     OWNER  TAGS                 POOL     VLAN      FABRIC    SUBNET
 --------      -----   -----  ------     -----  ----                 ----     ----      ------    ------
 lxd-vm-1      r8d6yp  off    Deployed   admin  pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
 lxd-vm-2      tfftrx  off    Allocated  admin  pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
 lxd-vm-3      grwpwc  off    Ready      -      pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
 lxd-vm-4      6s8dt4  off    Deployed   admin  pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
 lxd-vm-5      pyebgm  off    Allocated  admin  pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
 lxd-vm-6      ebnww6  off    New        -      pod-console-logging  default  untagged  fabric-1  
 libvirt-vm-1  m7ffsg  off    Ready      -      pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
 libvirt-vm-2  kpawad  off    Ready      -      pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
 libvirt-vm-3  r44hr6  error  Ready      -      pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
 libvirt-vm-4  s3sdkw  off    Ready      -      pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
 libvirt-vm-5  48dg8m  off    Ready      -      pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
 libvirt-vm-6  bacx77  on     Deployed   admin  pod-console-logging  default  untagged  fabric-1  10.124.141.0/24</textarea>
</p>

<p>
Here we have a clean text table listing the machine hostnames, along with the system IDs, power states, machines statuses, tags, pools, and networking information. These parameters represent only a small fraction of the available JSON output, of course. Let's break this command down, piece by piece, and see how it works.
</p>
</div>

<div id="outline-container-orgb7d8a67" class="outline-3">
<h3 id="orgb7d8a67">Basic jq usage</h3>
<div class="outline-text-3" id="text-orgb7d8a67">
<p>
First, we'll just pull the hostnames from these machines, with no qualifiers or formatting rules, like this:
</p>

<p>
<textarea cols="80" rows="1">
stormrider@wintermute:~$ maas admin machines read | jq '(.[] | [.hostname])'</textarea>
</p>

<p>
This command returns output that looks something like this:
</p>

<p>
<textarea cols="80" rows="36">
[
  "lxd-vm-1"
]
[
  "lxd-vm-2"
]
[
  "lxd-vm-3"
]
[
  "lxd-vm-4"
]
[
  "lxd-vm-5"
]
[
  "lxd-vm-6"
]
[
  "libvirt-vm-1"
]
[
  "libvirt-vm-2"
]
[
  "libvirt-vm-3"
]
[
  "libvirt-vm-4"
]
[
  "libvirt-vm-5"
]
[
  "libvirt-vm-6"
]</textarea>
</p>

<p>
Note a couple of things about this command:
</p>

<p>
<textarea cols="80" rows="1">
stormrider@wintermute:~$ maas admin machines read | jq '(.[] | [.hostname])'</textarea>
</p>

<p>
First, the jq instructions are enclosed in single quotes. As such, they can span lines if necessary, without any line continuations (\), like this:
</p>

<p>
<textarea cols="80" rows="2">
stormrider@wintermute:~$ maas admin machines read | jq '(.[]
| [.hostname])'</textarea>
</p>

<p>
Second, notice the structure of the jq instructions. The .[] tells jq that it's decoding an array of data sets  in this case, an array of machine data sets  and that it should iterate through each of the outer data sets (each machine) individually. The pipe symbol (|) completes the for each construct, so this command basically says, for each set of machine data you get, pull out (and return) the value associated with the JSON key hostname. The return value reflects this structure:
</p>

<p>
<textarea cols="80" rows="6">
[
   "libvirt-vm-5"
]
[
   "libvirt-vm-6"
]</textarea>
</p>

<p>
The outer square brackets represent the boundaries of each machine's data set, and the value in quotes corresponds to the value of the key hostname in successive machine data sets. It can get a little complicated sometimes, but that's basically the way to parse JSON with jq.
</p>

<p>
For practice let's try pulling the value of the key that holds machine status, again with no qualifiers or special formatting:
</p>

<p>
<textarea cols="80" rows="1">
stormrider@wintermute:~$ maas admin machines read | jq '(.[] | [.hostname, .status_name])'</textarea>
</p>

<p>
This command essentially tells jq to do the same thing as last time, but also collect the value of the key statusname for each machine. The results looks something like this:
</p>

<p>
<textarea cols="80" rows="48">
[
  "lxd-vm-1",
  "Deployed"
]
[
  "lxd-vm-2",
  "Allocated"
]
[
  "lxd-vm-3",
  "Ready"
]
[
  "lxd-vm-4",
  "Deployed"
]
[
  "lxd-vm-5",
  "Allocated"
]
[
  "lxd-vm-6",
  "New"
]
[
  "libvirt-vm-1",
  "Ready"
]
[
  "libvirt-vm-2",
  "Ready"
]
[
  "libvirt-vm-3",
  "Ready"
]
[
  "libvirt-vm-4",
  "Ready"
]
[
  "libvirt-vm-5",
  "Ready"
]
[
  "libvirt-vm-6",
  "Deployed"
]</textarea>
</p>

<p>
So much for printing the values of JSON keys. There are still some nuances (arrays, nested keys, ), but this is the lion's share of the syntax. Let's divert for a minute and look at how to format the output in a more human-readable way.
</p>
</div>
</div>

<div id="outline-container-org59373cc" class="outline-3">
<h3 id="org59373cc">Improved formatting</h3>
<div class="outline-text-3" id="text-org59373cc">
<p>
Most of the Ubuntu text-processing commands use tabs as field delimiters, which is a trait inherited from grandfather UNIX. Currently, the output is clean, but relatively hard to format into lines. Luckily jq has a filter for this: the tab-separated values filter, known as @tsv. This filter transforms the output records into individual lines with values separated by tabs.
</p>

<p>
Adding @tsv to the mix:
</p>

<p>
<textarea cols="80" rows="1">
stormrider@wintermute:~$ maas admin machines read | jq '(.[] | [.hostname, .status_name]) | @tsv'</textarea>
</p>

<p>
we get something like this:
</p>

<p>
<textarea cols="80" rows="12">
"lxd-vm-1\tDeployed"
"lxd-vm-2\tAllocated"
"lxd-vm-3\tReady"
"lxd-vm-4\tDeployed"
"lxd-vm-5\tAllocated"
"lxd-vm-6\tNew"
"libvirt-vm-1\tReady"
"libvirt-vm-2\tReady"
"libvirt-vm-3\tReady"
"libvirt-vm-4\tReady"
"libvirt-vm-5\tReady"
"libvirt-vm-6\tDeployed"</textarea>
</p>

<p>
That's a step in the right direction, but it's still pretty far from human-readable output. If only there were some way to get rid of the quotes and just do the tab, instead of representing it as a regex character. In fact, the jq raw output option (-r) takes care of this:
</p>

<p>
<textarea cols="80" rows="1">
stormrider@wintermute:~$ maas admin machines read | jq -r '(.[] | [.hostname, .status_name]) | @tsv'</textarea>
</p>

<p>
Feeding the raw output into our three-filter set gives us a more readable result:
</p>

<p>
<textarea cols="80" rows="12">
lxd-vm-1	Deployed
lxd-vm-2	Allocated
lxd-vm-3	Ready
lxd-vm-4	Deployed
lxd-vm-5	Allocated
lxd-vm-6	New
libvirt-vm-1	Ready
libvirt-vm-2	Ready
libvirt-vm-3	Ready
libvirt-vm-4	Ready
libvirt-vm-5	Ready
libvirt-vm-6	Deployed</textarea>
</p>

<p>
This is tabulated, but the number of spaces between the columns is a little big, and, if there's an unusually long value in one of the fields, it may throw the tabulation off for that line. Something could have been added to jq for that, but there is no need, since Ubuntu already has the column utility. Piping the output of the command so far to column -t (-t for tabs) will normalize the tab spacing to the data and ensure that each column is exactly long enough for the longest value in that column:
</p>

<p>
<textarea cols="80" rows="1">
stormrider@wintermute:~$ maas admin machines read | jq -r '(.[] | [.hostname, .status_name]) | @tsv' | column -t</textarea>
</p>

<p>
This command result is very similar to the previous output, though you'll notice that the field spacing is neatly optimized to the data itself:
</p>

<p>
<textarea cols="80" rows="12">
lxd-vm-1      Deployed
lxd-vm-2      Allocated
lxd-vm-3      Ready
lxd-vm-4      Deployed
lxd-vm-5      Allocated
lxd-vm-6      New
libvirt-vm-1  Ready
libvirt-vm-2  Ready
libvirt-vm-3  Ready
libvirt-vm-4  Ready
libvirt-vm-5  Ready
libvirt-vm-6  Deployed</textarea>
</p>
</div>
</div>

<div id="outline-container-org93a12fe" class="outline-3">
<h3 id="org93a12fe">Making real tables</h3>
<div class="outline-text-3" id="text-org93a12fe">
<p>
So far, so good, but this still isn't a presentable data table. First of all, there are no headings. These can be added by passing a literal row to jq, like this:
</p>

<p>
<textarea cols="80" rows="1">
stormrider@wintermute:~$ maas admin machines read | jq -r '(["HOSTNAME","STATUS"]), (.[] | [.hostname, .status_name]) | @tsv' | column -t</textarea>
</p>

<p>
You'll note that there are two expressions in parenthesis (representing individual lines or rows). The first just contains the two column headings, while the second contains the for each construct that pulls the hostname and status out of the JSON. In essence, the first expression evaluates to just one row, since there's nothing to tell it to iterate. The second expression evaluates to one row per machine, since that's the level of data we're reading. Here's what we get from this command:
</p>

<p>
<textarea cols="80" rows="13">
HOSTNAME      STATUS
lxd-vm-1      Deployed
lxd-vm-2      Allocated
lxd-vm-3      Ready
lxd-vm-4      Deployed
lxd-vm-5      Allocated
lxd-vm-6      New
libvirt-vm-1  Ready
libvirt-vm-2  Ready
libvirt-vm-3  Ready
libvirt-vm-4  Ready
libvirt-vm-5  Ready
libvirt-vm-6  Deployed</textarea>
</p>

<p>
Nice, but it needs a horizontal rule, like a line of dashes, to separate the headings from the data. We can do this by essentially turning the one header row into two, using some jq macros to generate dashes lines of appropriate length:
</p>

<p>
<textarea cols="80" rows="2">
stormrider@wintermute:~$ maas admin machines read | jq -r '(["HOSTNAME","STATUS"] | 
(.,map(length*"-"))), (.[] | [.hostname, .status_name]) | @tsv' | column -t</textarea>
</p>

<p>
The expression | (.,) tells jq to convert the foregoing header row into two rows: the first contains the two headers, as in the previous row, and the second contains the result of a couple of macros (map and length). We won't detail those here, but the use of this construct produces the following output:
</p>

<p>
<textarea cols="80" rows="14">
HOSTNAME      STATUS
--------      ------
lxd-vm-1      Deployed
lxd-vm-2      Allocated
lxd-vm-3      Ready
lxd-vm-4      Deployed
lxd-vm-5      Allocated
lxd-vm-6      New
libvirt-vm-1  Ready
libvirt-vm-2  Ready
libvirt-vm-3  Ready
libvirt-vm-4  Ready
libvirt-vm-5  Ready
libvirt-vm-6  Deployed</textarea>
</p>
</div>
</div>

<div id="outline-container-org159f43c" class="outline-3">
<h3 id="org159f43c">Extending the list</h3>
<div class="outline-text-3" id="text-org159f43c">
<p>
Let's add a couple more fields, owner (which is sometimes blank), and systemid (which is never blank), to the output:
</p>

<p>
<textarea cols="80" rows="3">
stormrider@wintermute:~$ maas admin machines read | jq -r '(["HOSTNAME","STATUS", "OWNER", "SYSTEM-ID"] 
| (.,map(length*"-"))), (.[] | [.hostname, .status_name,.owner,.system_id]) 
| @tsv' | column -t</textarea>
</p>

<p>
This gives us the following result:
</p>

<p>
<textarea cols="80" rows="14">
HOSTNAME      STATUS     OWNER   SYSTEM-ID
--------      ------     -----   ---------
lxd-vm-1      Deployed   admin   r8d6yp
lxd-vm-2      Allocated  admin   tfftrx
lxd-vm-3      Ready      grwpwc  
lxd-vm-4      Deployed   admin   6s8dt4
lxd-vm-5      Allocated  admin   pyebgm
lxd-vm-6      New        ebnww6  
libvirt-vm-1  Ready      m7ffsg  
libvirt-vm-2  Ready      kpawad  
libvirt-vm-3  Ready      r44hr6  
libvirt-vm-4  Ready      s3sdkw  
libvirt-vm-5  Ready      48dg8m  
libvirt-vm-6  Deployed   admin   bacx77</textarea>
</p>

<p>
You'll notice right away there's a problem with the columns. Remember that only machines in the Allocated or Deployed state are owned by anyone, since that's what allocate/acquire means. The lines for the deployed and allocated machines lay out correctly, but the lines for the unowned machines are incorrectly formatted. We can fix this by using the jq alternate value construct (a // "b"), which can be loosely read, if not a, then b. We add it to the owner key like this:
</p>

<p>
<textarea cols="80" rows="3">
stormrider@wintermute:~$ maas admin machines read | jq -r '(["HOSTNAME","STATUS", "OWNER", "SYSTEM-ID"] 
| (.,map(length*"-"))), (.[] | [.hostname, .status_name,.owner // "-",.system_id]) 
| @tsv' | column -t</textarea>
</p>

<p>
Then the results line up nicely, based on the longest value in each key column:
</p>

<p>
<textarea cols="80" rows="14">
HOSTNAME      STATUS     OWNER  SYSTEM-ID
--------      ------     -----  ---------
lxd-vm-1      Deployed   admin  r8d6yp
lxd-vm-2      Allocated  admin  tfftrx
lxd-vm-3      Ready      -      grwpwc
lxd-vm-4      Deployed   admin  6s8dt4
lxd-vm-5      Allocated  admin  pyebgm
lxd-vm-6      New        -      ebnww6
libvirt-vm-1  Ready      -      m7ffsg
libvirt-vm-2  Ready      -      kpawad
libvirt-vm-3  Ready      -      r44hr6
libvirt-vm-4  Ready      -      s3sdkw
libvirt-vm-5  Ready      -      48dg8m
libvirt-vm-6  Deployed   admin  bacx77</textarea>
</p>
</div>
</div>

<div id="outline-container-org9798af9" class="outline-3">
<h3 id="org9798af9">Nested arrays</h3>
<div class="outline-text-3" id="text-org9798af9">
<p>
Machines have a nested array (of indeterminate length) for machine tags. In JSON terms, instead of having a single key-value pair at the top level, like this:
</p>

<p>
<textarea cols="80" rows="1">
"hostname": "libvirt-vm-6",</textarea>
</p>

<p>
tags are represented by nested arrays, like this:
</p>

<p>
<textarea cols="80" rows="4">
"tag_names": [
    "pod-console-logging",
    "virtual"
],</textarea>
</p>

<p>
Incorporating a random number of tags per machine into a neat table is beyond the scope of this particular section, but we can show the first tag in the table rows:
</p>

<p>
<textarea cols="80" rows="3">
stormrider@wintermute:~$ maas admin machines read | jq -r '(["HOSTNAME","STATUS", "OWNER", "SYSTEM-ID",
"FIRST TAG"] | (.,map(length*"-"))), (.[] | [.hostname, .status_name,
.owner // "-",.system_id,.tag_names[0] // "-"]) | @tsv' | column -t</textarea>
</p>

<p>
Where we would use .json-key-name for a non-nested value, we need only use .json-key-name[0] to refer to the first element of the nested array. Doing this produces the following result:
</p>

<p>
<textarea cols="80" rows="14">
HOSTNAME      STATUS     OWNER  SYSTEM-ID  FIRST                TAG
--------      ------     -----  ---------  ---------            
lxd-vm-1      Deployed   admin  r8d6yp     pod-console-logging  
lxd-vm-2      Allocated  admin  tfftrx     pod-console-logging  
lxd-vm-3      Ready      -      grwpwc     pod-console-logging  
lxd-vm-4      Deployed   admin  6s8dt4     pod-console-logging  
lxd-vm-5      Allocated  admin  pyebgm     pod-console-logging  
lxd-vm-6      New        -      ebnww6     pod-console-logging  
libvirt-vm-1  Ready      -      m7ffsg     pod-console-logging  
libvirt-vm-2  Ready      -      kpawad     pod-console-logging  
libvirt-vm-3  Ready      -      r44hr6     pod-console-logging  
libvirt-vm-4  Ready      -      s3sdkw     pod-console-logging  
libvirt-vm-5  Ready      -      48dg8m     pod-console-logging  
libvirt-vm-6  Deployed   admin  bacx77     pod-console-logging</textarea>
</p>

<p>
That's almost right, but notice that the heading separates on spaces between words. Let's try a better way, with an underscore:
</p>

<p>
<textarea cols="80" rows="3">
stormrider@wintermute:~$ maas admin machines read | jq -r '(["HOSTNAME","STATUS", "OWNER", "SYSTEM-ID",
"FIRST_TAG"] | (.,map(length*"-"))), (.[] | [.hostname, .status_name,
.owner // "-",.system_id,.tag_names[0] // "-"]) | @tsv' | column -t</textarea>
</p>

<p>
This version of the command produces the expected output:
</p>

<p>
<textarea cols="80" rows="14">
HOSTNAME      STATUS     OWNER  SYSTEM-ID  FIRST_TAG
--------      ------     -----  ---------  ---------
lxd-vm-1      Deployed   admin  r8d6yp     pod-console-logging
lxd-vm-2      Allocated  admin  tfftrx     pod-console-logging
lxd-vm-3      Ready      -      grwpwc     pod-console-logging
lxd-vm-4      Deployed   admin  6s8dt4     pod-console-logging
lxd-vm-5      Allocated  admin  pyebgm     pod-console-logging
lxd-vm-6      New        -      ebnww6     pod-console-logging
libvirt-vm-1  Ready      -      m7ffsg     pod-console-logging
libvirt-vm-2  Ready      -      kpawad     pod-console-logging
libvirt-vm-3  Ready      -      r44hr6     pod-console-logging
libvirt-vm-4  Ready      -      s3sdkw     pod-console-logging
libvirt-vm-5  Ready      -      48dg8m     pod-console-logging
libvirt-vm-6  Deployed   admin  bacx77     pod-console-logging</textarea>
</p>
</div>
</div>

<div id="outline-container-org083446b" class="outline-3">
<h3 id="org083446b">Nested keys</h3>
<div class="outline-text-3" id="text-org083446b">
<p>
These aren't all the routine key-value pairs we want in the table, though. It would also be nice to print the pool to which each machine is assigned. Just asking for .pool as a single key-value pair:
</p>

<p>
<textarea cols="80" rows="3">
stormrider@wintermute:~$ maas admin machines read | jq -r '(["HOSTNAME","STATUS", "OWNER", "SYSTEM-ID",
"FIRST_TAG","POOL"] | (.,map(length*"-"))), (.[] | [.hostname, .status_name,
.owner // "-",.system_id,.tag_names[0] // "-", .pool]) | @tsv' | column -t</textarea>
</p>

<p>
produces an error:
</p>

<p>
<textarea cols="80" rows="1">
jq: error (at <stdin>:5639): object ({"name":"de...") is not valid in a csv row</textarea>
</p>

<p>
Looking at the JSON output, we see that .pool is a nested key, not a key-value pair:
</p>

<p>
<textarea cols="80" rows="6">
"pool": {
    "name": "default",
    "description": "Default pool",
    "id": 0,
    "resource_uri": "/MAAS/api/2.0/resourcepool/0/"
},</textarea>
</p>

<p>
What we really want is the pool name, so we need to add one level of indirection to that particular key to reach the actual key-value pair, like this:
</p>

<p>
<textarea cols="80" rows="3">
stormrider@wintermute:~$ maas admin machines read | jq -r '(["HOSTNAME","STATUS", "OWNER", "SYSTEM-ID",
"FIRST_TAG","POOL"] | (.,map(length*"-"))), (.[] | [.hostname, .status_name,
.owner // "-",.system_id,.tag_names[0] // "-", .pool.name]) | @tsv' | column -t</textarea>
</p>

<p>
which gives us what we want:
</p>

<p>
<textarea cols="80" rows="14">
HOSTNAME      STATUS     OWNER  SYSTEM-ID  FIRST_TAG            POOL
--------      ------     -----  ---------  ---------            ----
lxd-vm-1      Deployed   admin  r8d6yp     pod-console-logging  default
lxd-vm-2      Allocated  admin  tfftrx     pod-console-logging  default
lxd-vm-3      Ready      -      grwpwc     pod-console-logging  default
lxd-vm-4      Deployed   admin  6s8dt4     pod-console-logging  default
lxd-vm-5      Allocated  admin  pyebgm     pod-console-logging  default
lxd-vm-6      New        -      ebnww6     pod-console-logging  default
libvirt-vm-1  Ready      -      m7ffsg     pod-console-logging  default
libvirt-vm-2  Ready      -      kpawad     pod-console-logging  default
libvirt-vm-3  Ready      -      r44hr6     pod-console-logging  default
libvirt-vm-4  Ready      -      s3sdkw     pod-console-logging  default
libvirt-vm-5  Ready      -      48dg8m     pod-console-logging  default
libvirt-vm-6  Deployed   admin  bacx77     pod-console-logging  default</textarea>
</p>

<p>
It's also useful to list the VLAN and fabric names in the output table. Looking at the JSON again, these values present like this:
</p>

<p>
<textarea cols="80" rows="16">
"boot_interface": {
            "vlan": {
                "vid": 0,
                "mtu": 1500,
                "dhcp_on": true,
                "external_dhcp": null,
                "relay_vlan": null,
                "secondary_rack": null,
                "name": "untagged",
                "id": 5001,
                "fabric_id": 1,
                "space": "undefined",
                "fabric": "fabric-1",
                "primary_rack": "wnmkpn",
                "resource_uri": "/MAAS/api/2.0/vlans/5001/"
             },</textarea>
</p>

<p>
This means they are doubly-nested. No problem; just use double indirection (two levels of . separators) to retrieve them:
</p>

<p>
<textarea cols="80" rows="5">
stormrider@wintermute:~$ maas admin machines read | jq -r '(["HOSTNAME","SYSID","POWER","STATUS","OWNER", 
"TAGS", "POOL", "VLAN","FABRIC"] | (., map(length*"-"))), (.[] | [.hostname, 
.system_id, .power_state, .status_name, .owner // "-", .tag_names[0] // "-", 
.pool.name, .boot_interface.vlan.name, .boot_interface.vlan.fabric]) 
| @tsv' | column -t</textarea>
</p>

<p>
The modified command yields the desired results:
</p>

<p>
<textarea cols="80" rows="14">
HOSTNAME      SYSID   POWER  STATUS     OWNER  TAGS                 POOL     VLAN      FABRIC
--------      -----   -----  ------     -----  ----                 ----     ----      ------
lxd-vm-1      r8d6yp  off    Deployed   admin  pod-console-logging  default  untagged  fabric-1
lxd-vm-2      tfftrx  off    Allocated  admin  pod-console-logging  default  untagged  fabric-1
lxd-vm-3      grwpwc  off    Ready      -      pod-console-logging  default  untagged  fabric-1
lxd-vm-4      6s8dt4  off    Deployed   admin  pod-console-logging  default  untagged  fabric-1
lxd-vm-5      pyebgm  off    Allocated  admin  pod-console-logging  default  untagged  fabric-1
lxd-vm-6      ebnww6  off    New        -      pod-console-logging  default  untagged  fabric-1
libvirt-vm-1  m7ffsg  off    Ready      -      pod-console-logging  default  untagged  fabric-1
libvirt-vm-2  kpawad  off    Ready      -      pod-console-logging  default  untagged  fabric-1
libvirt-vm-3  r44hr6  error  Ready      -      pod-console-logging  default  untagged  fabric-1
libvirt-vm-4  s3sdkw  off    Ready      -      pod-console-logging  default  untagged  fabric-1
libvirt-vm-5  48dg8m  off    Ready      -      pod-console-logging  default  untagged  fabric-1
libvirt-vm-6  bacx77  on     Deployed   admin  pod-console-logging  default  untagged  fabric-1</textarea>
</p>

<p>
There's just one more (deeply nested) value we want to retrieve, and that's the fully-qualified subnet address in CIDR form. That's a little trickier, because it's buried in JSON like this:
</p>

<p>
<textarea cols="80" rows="20">
"boot_interface": {
     "vlan": {
         "vid": 0,
         "mtu": 1500,
         "dhcp_on": true,
         ...
         "resource_uri": "/MAAS/api/2.0/vlans/5001/"
     },
     "parents": [],
     "product": null,
     ...
     "link_connected": true,
     "type": "physical",
     "links": [
         {
             "id": 79,
             "mode": "auto",
             "ip_address": "10.124.141.4",
             "subnet": {
                 "name": "10.124.141.0/24",</textarea>
</p>

<p>
So the value we want is in the nested key bootinterface, in a nested array links[], which contains the doubly-nested key subnet.name. We can finish our basic CLI machine list  the one we started with  by adding this complex formulation to the command:
</p>

<p>
<textarea cols="80" rows="6">
stormrider@wintermute:~$ maas admin machines read | jq -r '(["HOSTNAME","SYSID","POWER","STATUS",
"OWNER", "TAGS", "POOL", "VLAN","FABRIC","SUBNET"] | (., map(length*"-"))),
(.[] | [.hostname, .system_id, .power_state, .status_name, .owner // "-", 
.tag_names[0] // "-", .pool.name,
.boot_interface.vlan.name, .boot_interface.vlan.fabric,
.boot_interface.links[0].subnet.name]) | @tsv' | column -t</textarea>
</p>

<p>
Sure enough, this command gives us the same table we had at the beginning of this section:
</p>

<p>
<textarea cols="80" rows="14">
HOSTNAME      SYSID   POWER  STATUS     OWNER  TAGS                 POOL     VLAN      FABRIC    SUBNET
--------      -----   -----  ------     -----  ----                 ----     ----      ------    ------
lxd-vm-1      r8d6yp  off    Deployed   admin  pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
lxd-vm-2      tfftrx  off    Allocated  admin  pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
lxd-vm-3      grwpwc  off    Ready      -      pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
lxd-vm-4      6s8dt4  off    Deployed   admin  pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
lxd-vm-5      pyebgm  off    Allocated  admin  pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
lxd-vm-6      ebnww6  off    New        -      pod-console-logging  default  untagged  fabric-1  
libvirt-vm-1  m7ffsg  off    Ready      -      pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
libvirt-vm-2  kpawad  off    Ready      -      pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
libvirt-vm-3  r44hr6  error  Ready      -      pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
libvirt-vm-4  s3sdkw  off    Ready      -      pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
libvirt-vm-5  48dg8m  off    Ready      -      pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
libvirt-vm-6  bacx77  on     Deployed   admin  pod-console-logging  default  untagged  fabric-1  10.124.141.0/24</textarea>
</p>
</div>
</div>

<div id="outline-container-orgea57b16" class="outline-3">
<h3 id="orgea57b16">Chaining Ubuntu CLI commands</h3>
<div class="outline-text-3" id="text-orgea57b16">
<p>
Although the machine list above looks fairly neat, it's actually not sorted by hostname, exactly. To accomplish this, we'd need to add a couple of Ubuntu CLI commands to the mix. Sorting on hostname means we want to sort on field 1 of the current command's output. We can try just feeding that to sort like this:
</p>

<p>
<textarea cols="80" rows="6">
stormrider@wintermute:~$ maas admin machines read | jq -r '(["HOSTNAME","SYSID","POWER","STATUS", "OWNER", 
"TAGS", "POOL", "VLAN","FABRIC","SUBNET"] | (., map(length*"-"))), (.[] | 
[.hostname, .system_id, .power_state, .status_name, .owner // "-", 
.tag_names[0] // "-", .pool.name, .boot_interface.vlan.name, 
.boot_interface.vlan.fabric, .boot_interface.links[0].subnet.name]) 
| @tsv' | column -t | sort -k 1</textarea>
</p>

<p>
This command does indeed sort by hostname:
</p>

<p>
<textarea cols="80" rows="14">
--------      -----   -----  ------     -----  ----                 ----     ----      ------    ------
HOSTNAME      SYSID   POWER  STATUS     OWNER  TAGS                 POOL     VLAN      FABRIC    SUBNET
libvirt-vm-1  m7ffsg  off    Ready      -      pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
libvirt-vm-2  kpawad  off    Ready      -      pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
libvirt-vm-3  r44hr6  error  Ready      -      pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
libvirt-vm-4  s3sdkw  off    Ready      -      pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
libvirt-vm-5  48dg8m  off    Ready      -      pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
libvirt-vm-6  bacx77  on     Deployed   admin  pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
lxd-vm-1      r8d6yp  off    Deployed   admin  pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
lxd-vm-2      tfftrx  off    Allocated  admin  pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
lxd-vm-3      grwpwc  off    Ready      -      pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
lxd-vm-4      6s8dt4  off    Deployed   admin  pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
lxd-vm-5      pyebgm  off    Allocated  admin  pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
lxd-vm-6      ebnww6  off    New        -      pod-console-logging  default  untagged  fabric-1</textarea>
</p>

<p>
but it has the unintended side-effect of sorting the header lines into the output. There are probably at least a dozen Ubuntu CLI solutions for this, so we'll just pick one of the most elegant here, using awk:
</p>

<p>
<textarea cols="80" rows="6">
stormrider@wintermute:~$ maas admin machines read | jq -r '(["HOSTNAME","SYSID","POWER","STATUS","OWNER", 
"TAGS", "POOL", "VLAN","FABRIC","SUBNET"] | (., map(length*"-"))),(.[] | 
[.hostname, .system_id, .power_state, .status_name, .owner // "-", 
.tag_names[0] // "-", .pool.name, .boot_interface.vlan.name, 
.boot_interface.vlan.fabric,.boot_interface.links[0].subnet.name]) 
| @tsv' | column -t | awk 'NR<3{print $0;next}{print $0| "sort -k 1"}'</textarea>
</p>

<p>
This command gives us the desired output:
</p>

<p>
<textarea cols="80" rows="14">
HOSTNAME      SYSID   POWER  STATUS     OWNER  TAGS                 POOL     VLAN      FABRIC    SUBNET
--------      -----   -----  ------     -----  ----                 ----     ----      ------    ------
libvirt-vm-1  m7ffsg  off    Ready      -      pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
libvirt-vm-2  kpawad  off    Ready      -      pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
libvirt-vm-3  r44hr6  error  Ready      -      pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
libvirt-vm-4  s3sdkw  off    Ready      -      pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
libvirt-vm-5  48dg8m  off    Ready      -      pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
libvirt-vm-6  bacx77  on     Deployed   admin  pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
lxd-vm-1      r8d6yp  off    Deployed   admin  pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
lxd-vm-2      tfftrx  off    Allocated  admin  pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
lxd-vm-3      grwpwc  off    Ready      -      pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
lxd-vm-4      6s8dt4  off    Deployed   admin  pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
lxd-vm-5      pyebgm  off    Allocated  admin  pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
lxd-vm-6      ebnww6  off    New        -      pod-console-logging  default  untagged  fabric-1</textarea>
</p>

<p>
Note that by changing the numerical -k argument to sort, you can change which field controls the sort:
</p>

<p>
<textarea cols="80" rows="6">
stormrider@wintermute:~$ maas admin machines read | jq -r '(["HOSTNAME","SYSID","POWER","STATUS","OWNER", 
"TAGS", "POOL", "VLAN","FABRIC","SUBNET"] | (., map(length*"-"))),(.[] | 
[.hostname, .system_id, .power_state, .status_name, .owner // "-", 
.tag_names[0] // "-", .pool.name, .boot_interface.vlan.name, 
.boot_interface.vlan.fabric,.boot_interface.links[0].subnet.name]) 
| @tsv' | column -t | awk 'NR<3{print $0;next}{print $0| "sort -k 4"}'</textarea>
</p>

<p>
This command sorts by machine state, which is the fourth field:
</p>

<p>
<textarea cols="80" rows="14">
HOSTNAME      SYSID   POWER  STATUS     OWNER  TAGS                 POOL     VLAN      FABRIC    SUBNET
--------      -----   -----  ------     -----  ----                 ----     ----      ------    ------
lxd-vm-2      tfftrx  off    Allocated  admin  pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
lxd-vm-5      pyebgm  off    Allocated  admin  pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
libvirt-vm-6  bacx77  on     Deployed   admin  pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
lxd-vm-1      r8d6yp  off    Deployed   admin  pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
lxd-vm-4      6s8dt4  off    Deployed   admin  pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
lxd-vm-6      ebnww6  off    New        -      pod-console-logging  default  untagged  fabric-1  
libvirt-vm-1  m7ffsg  off    Ready      -      pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
libvirt-vm-2  kpawad  off    Ready      -      pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
libvirt-vm-4  s3sdkw  off    Ready      -      pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
libvirt-vm-5  48dg8m  off    Ready      -      pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
lxd-vm-3      grwpwc  off    Ready      -      pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
libvirt-vm-3  r44hr6  error  Ready      -      pod-console-logging  default  untagged  fabric-1  10.124.141.0/24</textarea>
</p>

<p>
At this point, it should be clear that jq is a relatively simple, powerful tool for formatting output from the MAAS CLI. You should also remember that, like any Ubuntu CLI command, jq simply outputs text  so anything you can do with text output, you can do with the output from jq.
</p>
</div>
</div>
</div>

<div id="outline-container-orgdb84081" class="outline-2">
<h2 id="orgdb84081">SSH/SCP with MAAS machines</h2>
<div class="outline-text-2" id="text-orgdb84081">
<p>
Now that we have some running machines, what if we just set ourselves up to SSH into one of them? Making this work will also allow us to scp files in &#x2013; and I'm sure you can see how we'd provision a machine from there. We can also do the provisioning with MAAS, if we're clever, but I'll leave that for later.
</p>

<p>
First things first: we need to build the MAAS infrastructure necessary to play with this feature.
</p>
</div>

<div id="outline-container-org2ae5039" class="outline-3">
<h3 id="org2ae5039">Create a KVM</h3>
<div class="outline-text-3" id="text-org2ae5039">
<p>
We start by creating a vm-host. Let's play dumb and walk our way through this; first, we'll just try creating a vm-host, like this:
</p>

<p>
<textarea cols="80" rows="1">
maas admin vm-host create</textarea>
</p>

<p>
This doesn't give anything like the expected result:
</p>

<p>
<textarea cols="80" rows="23">
usage: maas admin vm-host [-h] COMMAND ...

Manage an individual vm-host.

optional arguments:
  -h, --help  show this help message and exit

drill down:
  COMMAND
    refresh   Refresh a pod
    parameters
              Obtain pod parameters
    compose   Compose a pod machine
    add-tag   Add a tag to a pod
    remove-tag
              Remove a tag from a pod
    read
    update    Update a specific pod
    delete    Deletes a pod

A vm-host is identified by its id.

argument COMMAND: invalid choice: 'create' (choose from 'refresh', 'parameters', 'compose', 'add-tag', 'remove-tag', 'read', 'update', 'delete')</textarea>
</p>

<p>
Oops, forgot about the collective pluralism of the MAAS CLI &#x2013; we need to use vm-hosts to create one, because we're adding to the collection, so the correct command should look something like this:
</p>

<p>
<textarea cols="80" rows="1">
maas admin vm-hosts create</textarea>
</p>

<p>
Still not quite what we expected, but we're failing forward fast, which is a great way to learn new software. As a side note, it's not great for skydiving, but that's another story altogether. The MAAS CLI tells us we need to specify a type:
</p>

<p>
<textarea cols="80" rows="1">
{"type": ["This field is required."]}</textarea>
</p>

<p>
Of course! We have to specify what kind of vm-host we want; in this case, it's going to be an LXD vm-host, so we modify our previous command like this:
</p>

<p>
<textarea cols="80" rows="1">
maas admin vm-hosts create type=lxd</textarea>
</p>

<p>
Oops, still one more thing to enter: the power_address:
</p>

<p>
<textarea cols="80" rows="1">
{"power_address": ["This field is required."]}</textarea>
</p>

<p>
We need to update our command to tell MAAS what LXD instance we're going to use. The power_address for an LXD vm-host is of the form <code>https://&lt;gateway-ip-address&gt;:8443</code>. The <code>8443</code> is the default port when you ran lxd init to get LXD started, after installing it. The rest is just what you learn by experience, or by reading blogs like this one.
</p>

<p>
In my case, the LXD gateway is 10.38.31.1 at the moment, so my modified command would be:
</p>

<p>
<textarea cols="80" rows="1">
maas admin vm-hosts create type=lxd power_address=https://10.38.31.1:8443</textarea>
</p>

<p>
Within seconds, we get a success message and JSON output. From now on, I'll leave the JSON output for you to generate and view on your own, unless it bears specifically on the discussion. In this case, all that we'll need is the last non-bracket line of the JSON return, which is:
</p>

<p>
<textarea cols="80" rows="1">
"resource_uri": "/MAAS/api/2.0/pods/7/"</textarea>
</p>

<p>
What we'll need in the next step is the vm-host ID, which is the number on the end of the resource_uri &#x2013; specifically, "7".
</p>

<p>
By way of additional confirmation, we could pull up the MAAS UI and see that an LXD "KVM HOST TYPE" named "wintermute" has been created. This might be a good moment to bring up some terminology dissonance, which is nothing unusual for an open-source product. Originally, vm-hosts were called "pods," hence the word "pods" in the resource URI. Later, they were changed to "KVM hosts" to correspond to the term "KVM," used commonly by libvirt. Note that libvirt was, at one time, the only common vm-host used by MAAS. As the product transitioned to using more than one VM tool &#x2013; that is, LXD &#x2013; the team decided a more inclusive name was needed, hence "VM host."
</p>
</div>
</div>

<div id="outline-container-orge05ae5c" class="outline-3">
<h3 id="orge05ae5c">Composing a machine</h3>
<div class="outline-text-3" id="text-orge05ae5c">
<p>
Having a VM host is great, but we can't demonstrate ssh/scp machine actions without a virtual machine running on that host. Let's create one. This may get tricky, so let's start by looking at the MAAS CLI help:
</p>

<p>
<textarea cols="80" rows="1">
maas admin --help</textarea>
</p>

<p>
This gives us the following, very long command list:
</p>

<p>
<textarea cols="80" rows="129">
usage: maas admin [-h] COMMAND ...

Issue commands to the MAAS region controller at http://192.168.56.91:5240/MAAS/api/2.0/.

optional arguments:
  -h, --help            show this help message and exit

drill down:
  COMMAND
    account             Manage the current logged-in user.
    bcache-cache-set    Manage bcache cache set on a machine.
    bcache-cache-sets   Manage bcache cache sets on a machine.
    bcache              Manage bcache device on a machine.
    bcaches             Manage bcache devices on a machine.
    block-device        Manage a block device on a machine.
    block-devices       Manage block devices on a machine.
    boot-resource       Manage a boot resource.
    boot-resources      Manage the boot resources.
    boot-source         Manage a boot source.
    boot-source-selection
                        Manage a boot source selection.
    boot-source-selections
                        Manage the collection of boot source selections.
    boot-sources        Manage the collection of boot sources.
    commissioning-script
                        Manage a custom commissioning script.
    commissioning-scripts
                        Manage custom commissioning scripts.
    dhcpsnippet         Manage an individual DHCP snippet.
    dhcpsnippets        Manage the collection of all DHCP snippets in MAAS.
    dnsresource         Manage dnsresource.
    dnsresource-record  Manage dnsresourcerecord.
    dnsresource-records
                        Manage DNS resource records (e.g. CNAME, MX, NS, SRV,
                        TXT)
    dnsresources        Manage dnsresources.
    device              Manage an individual device.
    devices             Manage the collection of all the devices in the MAAS.
    discoveries         Query observed discoveries.
    discovery           Read or delete an observed discovery.
    domain              Manage domain.
    domains             Manage domains.
    events              Retrieve filtered node events.
    fabric              Manage fabric.
    fabrics             Manage fabrics.
    fan-network         Manage Fan Network.
    fan-networks        Manage Fan Networks.
    file                Manage a FileStorage object.
    files               Manage the collection of all the files in this MAAS.
    ipaddresses         Manage IP addresses allocated by MAAS.
    iprange             Manage IP range.
    ipranges            Manage IP ranges.
    interface           Manage a node's or device's interface.
    interfaces          Manage interfaces on a node.
    license-key         Manage a license key.
    license-keys        Manage the license keys.
    maas                Manage the MAAS server.
    machine             Manage an individual machine.
    machines            Manage the collection of all the machines in the MAAS.
    network             Manage a network.
    networks            Manage the networks.
    node                Manage an individual Node.
    node-results        Read the collection of commissioning script results.
    node-script         Manage or view a custom script.
    node-script-result  Manage node script results.
    node-script-results
                        Manage node script results.
    node-scripts        Manage custom scripts.
    nodes               Manage the collection of all the nodes in the MAAS.
    notification        Manage an individual notification.
    notifications       Manage the collection of all the notifications in
                        MAAS.
    package-repositories
                        Manage the collection of all Package Repositories in
                        MAAS.
    package-repository  Manage an individual package repository.
    partition           Manage partition on a block device.
    partitions          Manage partitions on a block device.
    pod                 Manage an individual pod.
    pods                Manage the collection of all the pod in the MAAS.
    rack-controller     Manage an individual rack controller.
    rack-controllers    Manage the collection of all rack controllers in MAAS.
    raid                Manage a specific RAID (Redundant Array of Independent
                        Disks) on a machine.
    raids               Manage all RAIDs (Redundant Array of Independent
                        Disks) on a machine.
    region-controller   Manage an individual region controller.
    region-controllers  Manage the collection of all region controllers in
                        MAAS.
    resource-pool       Manage a resource pool.
    resource-pools      Manage resource pools.
    sshkey              Manage an SSH key.
    sshkeys             Manage the collection of all the SSH keys in this
                        MAAS.
    sslkey              Manage an SSL key.
    sslkeys             Operations on multiple keys.
    space               Manage space.
    spaces              Manage spaces.
    static-route        Manage static route.
    static-routes       Manage static routes.
    subnet              Manage subnet.
    subnets             Manage subnets.
    tag                 Tags are properties that can be associated with a Node
                        and serve as criteria for selecting and allocating
                        nodes.
    tags                Manage all tags known to MAAS.
    user                Manage a user account.
    users               Manage the user accounts of this MAAS.
    version             Information about this MAAS instance.
    virtual-machine     Manage individual virtual machines.
    virtual-machines    Manage a collection of virtual machines.
    vlan                Manage a VLAN on a fabric.
    vlans               Manage VLANs on a fabric.
    vm-host             Manage an individual vm-host.
    vm-hosts            Manage the collection of all the vm-hosts in the MAAS.
    vmfs-datastore      Manage VMFS datastore on a machine.
    vmfs-datastores     Manage VMFS datastores on a machine.
    volume-group        Manage volume group on a machine.
    volume-groups       Manage volume groups on a machine.
    zone                Manage a physical zone.
    zones               Manage physical zones.

This is a profile.  Any commands you issue on this profile will
operate on the MAAS region server.

The command information you see here comes from the region server's
API; it may differ for different profiles.  If you believe the API may
have changed, use the command's 'refresh' sub-command to fetch the
latest version of this help information from the server.</textarea>
</p>

<p>
We're looking to compose a machine here, so where would you look instinctively? Well, the first thought might be machines, so we can give that help screen a try:
</p>

<p>
<textarea cols="80" rows="1">
maas admin machines --help</textarea>
</p>

<p>
This produces a few commands:
</p>

<p>
<textarea cols="80" rows="23">
usage: maas admin machines [-h] COMMAND ...

Manage the collection of all the machines in the MAAS.

optional arguments:
  -h, --help            show this help message and exit

drill down:
  COMMAND
    is-registered       MAC address registered
    set-zone            Assign nodes to a zone
    power-parameters    Get power parameters
    accept              Accept declared machines
    accept-all          Accept all declared machines
    release             Release machines
    list-allocated      List allocated
    allocate            Allocate a machine
    add-chassis         Add special hardware
    clone               Clone storage and/or interface configurations
    read                List Nodes visible to the user
    create              Create a new machine
    is-action-in-progress
                        MAC address of deploying or commissioning node</textarea>
</p>

<p>
This list is interesting, but there isn't a specific compose command here. We could go down the garden path with maas admin machines create, but first, let's see if the vm-host command has anything we're seeking:
</p>

<p>
<textarea cols="80" rows="1">
maas admin vm-host --help</textarea>
</p>

<p>
Bingo. Found the command; do you see it in this list?
</p>

<p>
<textarea cols="80" rows="21">
usage: maas admin vm-host [-h] COMMAND ...

Manage an individual vm-host.

optional arguments:
  -h, --help  show this help message and exit

drill down:
  COMMAND
    refresh   Refresh a pod
    parameters
              Obtain pod parameters
    compose   Compose a pod machine
    add-tag   Add a tag to a pod
    remove-tag
              Remove a tag from a pod
    read
    update    Update a specific pod
    delete    Deletes a pod

A vm-host is identified by its id.</textarea>
</p>

<p>
Okay, so maas admin vm-host compose is the root command, let's see what it requires:
</p>

<p>
<textarea cols="80" rows="1">
maas admin vm-host compose --help</textarea>
</p>

<p>
Wow! This command is incredibly robust, including some NUMA stuff (which we'll look at later):
</p>

<p>
<textarea cols="80" rows="103">
usage: maas admin vm-host compose [--help] [-d] [-k] id [data [data ...]]

Compose a pod machine


Positional arguments:
        id


This method accepts keyword arguments.  Pass each argument as a
key-value pair with an equals sign between the key and the value:
key1=value1 key2=value key3=value3.  Keyword arguments must come after
any positional arguments.

Compose a new machine from a pod.

:param cores: Optional.  The minimum number of CPU cores.
:type cores: Int

 :param memory: Optional.  The minimum amount of memory,
specified in MiB (e.g. 2 MiB == 2*1024*1024).
:type memory: Int

 :param hugepages_backed: Optional.  Whether to request
hugepages backing for the machine.
:type hugepages_backed: Boolean

 :param pinned_cores: Optional.  List of host CPU cores
to pin the VM to. If this is passed, the "cores" parameter is ignored.
:type pinned_cores: Int

 :param cpu_speed: Optional.  The minimum CPU speed,
specified in MHz.
:type cpu_speed: Int

 :param architecture: Optional.  The architecture of
the new machine (e.g. amd64). This must be an architecture the pod
supports.
:type architecture: String

 :param storage: Optional.  A list of storage
constraint identifiers in the form ``label:size(tag,tag,...),
label:size(tag,tag,...)``. For more information please see the CLI
pod management page of the official MAAS documentation.
:type storage: String

 :param interfaces: Optional.  A
labeled constraint map associating constraint labels with desired
interface properties. MAAS will assign interfaces that match the
given interface properties.

Format: ``label:key=value,key=value,...``

Keys:

- ``id``: Matches an interface with the specific id
- ``fabric``: Matches an interface attached to the specified fabric.
- ``fabric_class``: Matches an interface attached to a fabric
  with the specified class.
- ``ip``: Matches an interface whose VLAN is on the subnet implied by
  the given IP address, and allocates the specified IP address for
  the machine on that interface (if it is available).
- ``mode``: Matches an interface with the specified mode. (Currently,
  the only supported mode is "unconfigured".)
- ``name``: Matches an interface with the specified name.
  (For example, "eth0".)
- ``hostname``: Matches an interface attached to the node with
  the specified hostname.
- ``subnet``: Matches an interface attached to the specified subnet.
- ``space``: Matches an interface attached to the specified space.
- ``subnet_cidr``: Matches an interface attached to the specified
  subnet CIDR. (For example, "192.168.0.0/24".)
- ``type``: Matches an interface of the specified type. (Valid
  types: "physical", "vlan", "bond", "bridge", or "unknown".)
- ``vlan``: Matches an interface on the specified VLAN.
- ``vid``: Matches an interface on a VLAN with the specified VID.
- ``tag``: Matches an interface tagged with the specified tag.
:type interfaces: String

 :param hostname: Optional.  The hostname of the newly
composed machine.
:type hostname: String

 :param domain: Optional.  The ID of the domain in which
to put the newly composed machine.
:type domain: Int

 :param zone: Optional.  The ID of the zone in which to
put the newly composed machine.
:type zone: Int

 :param pool: Optional.  The ID of the pool in which to
put the newly composed machine.
:type pool: Int


Common command-line options:
    --help, -h
        Show this help message and exit.
    -d, --debug
        Display more information about API responses.
    -k, --insecure
        Disable SSL certificate check</textarea>
</p>

<p>
We could get fancy, but for these purposes, we just need a machine. The only thing that's absolutely required besides the command we already got "help" for is the vm-host ID. Remember that line of JSON from above? The ID is "7" &#x2013; so we'll enter this command:
</p>

<p>
<textarea cols="80" rows="1">
maas admin vm-host compose 7</textarea>
</p>

<p>
Hey, how about that! We got some feedback with a machine system_id:
</p>

<p>
<textarea cols="80" rows="6">
Success.
Machine-readable output follows:
{
    "system_id": "xttpfx",
    "resource_uri": "/MAAS/api/2.0/machines/xttpfx/"
}</textarea>
</p>

<p>
We can use this, along with some of our jq tricks, to see if this machine is commissioning (as expected):
</p>

<p>
<textarea cols="80" rows="6">
maas admin machines read | jq -r '(["HOSTNAME","SYSID",
"POWER","STATUS","OWNER", "TAGS", "POOL","VLAN","FABRIC",
"SUBNET"] | (., map(length*"-"))),(.[] | [.hostname, .system_id, 
.power_state, .status_name, .owner // "-",.tag_names[0] // "-", 
.pool.name,.boot_interface.vlan.name,.boot_interface.vlan.fabric,
.boot_interface.links[0].subnet.name]) | @tsv' | column -t</textarea>
</p>

<p>
This gives the following output on my machine:
</p>

<p>
<textarea cols="80" rows="3">
HOSTNAME    SYSID   POWER  STATUS   OWNER  TAGS     POOL     VLAN      FABRIC    SUBNET
--------    -----   -----  ------   -----  ----     ----     ----      ------    ------
native-cub  xttpfx  on     Testing  admin  virtual  default  untagged  fabric-1  10.38.31.0/24</textarea>
</p>

<p>
By the time I got this command typed in, commissioning had already nearly finished, and the machine was in the "testing" phase. If we run this command again now, we should see that it's in the "Ready" state:
</p>

<p>
<textarea cols="80" rows="3">
HOSTNAME    SYSID   POWER  STATUS  OWNER  TAGS     POOL     VLAN      FABRIC    SUBNET
--------    -----   -----  ------  -----  ----     ----     ----      ------    ------
native-cub  xttpfx  off    Ready   -      virtual  default  untagged  fabric-1  10.38.31.0/24</textarea>
</p>
</div>
</div>

<div id="outline-container-orge4be9fd" class="outline-3">
<h3 id="orge4be9fd">Getting the machine to a login state</h3>
<div class="outline-text-3" id="text-orge4be9fd">
<p>
We can't SSH into it, because it automatically turned off after commissioning, and anyway, we didn't have a chance to ask for SSH keys to be loaded during the commissioning process. Let's run that commissioning again, with SSH keys enabled, and making sure that it's left on after it's done. For this operation, we just use the standard machine commands, because the vm-host is hosting a MAAS machine, which is the same as any other MAAS machine:
</p>

<p>
<textarea cols="80" rows="1">
maas admin machine commission xttpfx enable_ssh=1</textarea>
</p>

<p>
This will return a success message (be sure to substitute the "xttpfx" with whatever your composed machine system_id turns out to be; your mileage may vary). After a little while, the machine should return to a "Ready" state again, but this time, with the power left on, and with SSH keys passed to the machine, so that we can login to it. We can check this without complex jq command again:
</p>

<p>
<textarea cols="80" rows="3">
HOSTNAME    SYSID   POWER  STATUS  OWNER  TAGS     POOL     VLAN      FABRIC    SUBNET
--------    -----   -----  ------  -----  ----     ----     ----      ------    ------
native-cub  xttpfx  on     Ready   -      virtual  default  untagged  fabric-1  10.38.31.0/24</textarea>
</p>
</div>
</div>

<div id="outline-container-org8507ef7" class="outline-3">
<h3 id="org8507ef7">Logging into a commissioned machine</h3>
<div class="outline-text-3" id="text-org8507ef7">
<p>
So it's "Ready" and it's powered on, that's good. In order to log in, we'll need to know the machine's IP address. There are several ways to get this, but by far the easiest, IMHO, is just using the lxc command:
</p>

<p>
<textarea cols="80" rows="1">
lxc list</textarea>
</p>

<p>
This will give us the following output:
</p>

<p>
<textarea cols="80" rows="7">
+------------+---------+---------------------+-----------------------------------------------+-----------------+-----------+
|    NAME    |  STATE  |        IPV4         |                     IPV6                      |      TYPE       | SNAPSHOTS |
+------------+---------+---------------------+-----------------------------------------------+-----------------+-----------+
| first-one  | RUNNING | 10.38.31.193 (eth0) |                                               | CONTAINER       | 0         |
+------------+---------+---------------------+-----------------------------------------------+-----------------+-----------+
| native-cub | RUNNING | 10.38.31.202 (eth0) | fd42:fd4c:6ab9:19bc:216:3eff:fe9e:bc7b (eth0) | VIRTUAL-MACHINE | 0         |
+------------+---------+---------------------+-----------------------------------------------+-----------------+-----------+</textarea>
</p>

<p>
This brings up some important nuances about the LXD list. Note that there are two machines, one of which is a CONTAINER that I use for general testing of new software. The other, "native-cub," is the VIRTUAL-MACHINE we just created, and that's the one whose IP address we want for SSH purposes: 10.38.31.202.
</p>

<p>
Okay, so now we can try logging in via SSH, using the "ubuntu" user (always):
</p>

<p>
<textarea cols="80" rows="1">
ssh ubuntu@10.38.31.202</textarea>
</p>

<p>
We get the expected first-login response:
</p>

<p>
<textarea cols="80" rows="3">
The authenticity of host '10.38.31.202 (10.38.31.202)' can't be established.
ECDSA key fingerprint is SHA256:hkKRDyRDG9JcsSmAQ0ir5jy0UKQ+PrU/FTJr36U3bvw.
Are you sure you want to continue connecting (yes/no/[fingerprint])? </textarea>
</p>

<p>
And if we say "yes," we should get this result:
</p>

<p>
<textarea cols="80" rows="34">
Warning: Permanently added '10.38.31.202' (ECDSA) to the list of known hosts.
Welcome to Ubuntu 20.04.1 LTS (GNU/Linux 5.4.0-64-generic x86_64)

 * Documentation:  https://help.ubuntu.com
 * Management:     https://landscape.canonical.com
 * Support:        https://ubuntu.com/advantage

  System information as of Mon Feb  1 00:11:52 UTC 2021

  System load:    0.0       Processes:               127
  Usage of /home: unknown   Users logged in:         0
  Memory usage:   10%       IPv4 address for enp5s0: 10.38.31.202
  Swap usage:     0%

14 updates can be installed immediately.
2 of these updates are security updates.
To see these additional updates run: apt list --upgradable

tmpfs-root /media/root-rw tmpfs rw,relatime 0 0
overlayroot / overlay rw,relatime,lowerdir=/media/root-ro,upperdir=/media/root-rw/overlay,workdir=/media/root-rw/overlay-workdir/_ 0 0
/dev/loop0 /media/root-ro squashfs ro,relatime 0 0


The programs included with the Ubuntu system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Ubuntu comes with ABSOLUTELY NO WARRANTY, to the extent permitted by
applicable law.

To run a command as administrator (user "root"), use "sudo <command>".
See "man sudo_root" for details.

ubuntu@native-cub:~$ </textarea>
</p>
</div>
</div>

<div id="outline-container-orge68e360" class="outline-3">
<h3 id="orge68e360">Using SCP</h3>
<div class="outline-text-3" id="text-orge68e360">
<p>
We can jump out of this machine and use its IP address to copy files over to it. First, let's make sure that there isn't anything in the local directory on the machine:
</p>

<p>
<textarea cols="80" rows="1">
ls</textarea>
</p>

<p>
And we get what we'd expect:
</p>

<p>
<textarea cols="80" rows="2">
ubuntu@native-cub:~$ ls
ubuntu@native-cub:~$ </textarea>
</p>

<p>
So now, let's exit the machine with exit, and just touch a file called "zork" (a very uncommon filename) in the CWD on the local machine:
</p>

<p>
<textarea cols="80" rows="10">
ubuntu@native-cub:~$ exit
logout
Connection to 10.38.31.202 closed.
stormrider@wintermute:~$ touch zork
stormrider@wintermute:~$ ls
 api-key-file   Credentials   Dropbox   Pictures      snap            Templates
 Backups        Desktop       git       Public        stormrider.io   Videos
 BRF            Documents     mnt      '#scratch#'    temp            Websites
 Code           Downloads     Music     Show-n-Tell   temp~           zork
stormrider@wintermute:~$ </textarea>
</p>

<p>
Now, let's try to scp (secure copy) the file over to the machine, login, and see if the file made it:
</p>

<p>
<textarea cols="80" rows="32">
stormrider@wintermute:~$ scp ./zork ubuntu@10.38.31.202:
zork                                          100%    0     0.0KB/s   00:00    
stormrider@wintermute:~$ ssh ubuntu@10.38.31.202
Welcome to Ubuntu 20.04.1 LTS (GNU/Linux 5.4.0-64-generic x86_64)

 * Documentation:  https://help.ubuntu.com
 * Management:     https://landscape.canonical.com
 * Support:        https://ubuntu.com/advantage

  System information as of Mon Feb  1 00:20:42 UTC 2021

  System load:    0.0       Processes:               123
  Usage of /home: unknown   Users logged in:         0
  Memory usage:   10%       IPv4 address for enp5s0: 10.38.31.202
  Swap usage:     0%


14 updates can be installed immediately.
2 of these updates are security updates.
To see these additional updates run: apt list --upgradable

tmpfs-root /media/root-rw tmpfs rw,relatime 0 0
overlayroot / overlay rw,relatime,lowerdir=/media/root-ro,upperdir=/media/root-rw/overlay,workdir=/media/root-rw/overlay-workdir/_ 0 0
/dev/loop0 /media/root-ro squashfs ro,relatime 0 0

Last login: Mon Feb  1 00:19:34 2021 from 10.38.31.1
To run a command as administrator (user "root"), use "sudo <command>".
See "man sudo_root" for details.

ubuntu@native-cub:~$ ls
zork
ubuntu@native-cub:~$ </textarea>
</p>

<p>
Cool! So we can copy files to a machine! Neat.
</p>
</div>
</div>

<div id="outline-container-org2cd19df" class="outline-3">
<h3 id="org2cd19df">Copying files to a deployed machine</h3>
<div class="outline-text-3" id="text-org2cd19df">
<p>
Copying files to a commissioned machine doesn't do us much good, of course, since the machine gets wiped out and reloaded on deployment. Let's acquire and deploy that same machine, and then try logging in and copying files again. First, we have to acquire and deploy the machine:
</p>

<p>
<textarea cols="80" rows="1">
maas admin machines allocate system_id=xttpfx</textarea>
</p>
<p>
(Success message and JSON data stream)
</p>

<p>
<textarea cols="80" rows="1">
maas admin machine deploy xttpfx</textarea>
</p>
<p>
(Success message and JSON data stream)
</p>

<p>
<textarea cols="80" rows="10">
maas admin machines read | jq -r '(["HOSTNAME","SYSID", 
"POWER","STATUS","OWNER", "TAGS", "POOL","VLAN","FABRIC",
"SUBNET"] | (., map(length*"-"))),(.[] | [.hostname, .system_id, 
.power_state, .status_name, .owner // "-",.tag_names[0] // "-", 
.pool.name,.boot_interface.vlan.name,.boot_interface.vlan.fabric,
.boot_interface.links[0].subnet.name]) | @tsv' | column -t

HOSTNAME    SYSID   POWER  STATUS     OWNER  TAGS     POOL     VLAN      FABRIC    SUBNET
--------    -----   -----  ------     -----  ----     ----     ----      ------    ------
native-cub  xttpfx  on     Deploying  admin  virtual  default  untagged  fabric-1  10.38.31.0/24</textarea>
</p>

<p>
When it finally reaches the "Deployed" state, we can try and log into it:
</p>

<p>
<textarea cols="80" rows="16">
stormrider@wintermute:~$ ssh ubuntu@10.38.31.2
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!
Someone could be eavesdropping on you right now (man-in-the-middle attack)!
It is also possible that a host key has just been changed.
The fingerprint for the ECDSA key sent by the remote host is
SHA256:AsOdI357mZdmymQG/bmZzbtrDwZPKNYwdUDgCecHHhI.
Please contact your system administrator.
Add correct host key in /home/stormrider/.ssh/known_hosts to get rid of this message.
Offending ECDSA key in /home/stormrider/.ssh/known_hosts:20
  remove with:
  ssh-keygen -f "/home/stormrider/.ssh/known_hosts" -R "10.38.31.2"
ECDSA host key for 10.38.31.2 has changed and you have requested strict checking.
Host key verification failed.</textarea>
</p>

<p>
What??!!?? This is supposed to work, isn't it??
</p>

<p>
No worries! On deployment, the SSH key just got updated, so just do what the message suggests, and you can SSH in normally:
</p>

<p>
<textarea cols="80" rows="39">
stormrider@wintermute:~$ ssh-keygen -f "/home/stormrider/.ssh/known_hosts" -R "10.38.31.2"
# Host 10.38.31.2 found: line 20
/home/stormrider/.ssh/known_hosts updated.
Original contents retained as /home/stormrider/.ssh/known_hosts.old
stormrider@wintermute:~$ ssh ubuntu@10.38.31.2
The authenticity of host '10.38.31.2 (10.38.31.2)' can't be established.
ECDSA key fingerprint is SHA256:AsOdI357mZdmymQG/bmZzbtrDwZPKNYwdUDgCecHHhI.
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
Warning: Permanently added '10.38.31.2' (ECDSA) to the list of known hosts.
Welcome to Ubuntu 20.04.1 LTS (GNU/Linux 5.4.0-65-generic x86_64)

 * Documentation:  https://help.ubuntu.com
 * Management:     https://landscape.canonical.com
 * Support:        https://ubuntu.com/advantage

  System information as of Mon Feb  1 00:34:27 UTC 2021

  System load:  0.08              Processes:               133
  Usage of /:   48.2% of 6.78GB   Users logged in:         0
  Memory usage: 10%               IPv4 address for enp5s0: 10.38.31.2
  Swap usage:   0%

14 updates can be installed immediately.
2 of these updates are security updates.
To see these additional updates run: apt list --upgradable



The programs included with the Ubuntu system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Ubuntu comes with ABSOLUTELY NO WARRANTY, to the extent permitted by
applicable law.

To run a command as administrator (user "root"), use "sudo <command>".
See "man sudo_root" for details.

ubuntu@native-cub:~$ </textarea>
</p>
</div>
</div>

<div id="outline-container-orgca07192" class="outline-3">
<h3 id="orgca07192">Copying a script over there and running it</h3>
<div class="outline-text-3" id="text-orgca07192">
<p>
So first, let's verify that the script we want to copy over there isn't already there. In fact, to keep it simple, let's just create a simple and fun script to see what scp can get us. First, we'll need to install a couple of software packages on the deployed machine:
</p>

<p>
<textarea cols="80" rows="88">
ubuntu@native-cub:~$ fortune

Command 'fortune' not found, but can be installed with:

sudo apt install fortune-mod

ubuntu@native-cub:~$ sudo apt install fortune-mod
Reading package lists... Done
Building dependency tree       
Reading state information... Done
The following additional packages will be installed:
  fortunes-min librecode0
Suggested packages:
  fortunes x11-utils
The following NEW packages will be installed:
  fortune-mod fortunes-min librecode0
0 upgraded, 3 newly installed, 0 to remove and 17 not upgraded.
Need to get 615 kB of archives.
After this operation, 2135 kB of additional disk space will be used.
Do you want to continue? [Y/n] Y
Get:1 http://archive.ubuntu.com/ubuntu focal/main amd64 librecode0 amd64 3.6-24 [523 kB]
Get:2 http://archive.ubuntu.com/ubuntu focal/universe amd64 fortune-mod amd64 1:1.99.1-7build1 [37.3 kB]
Get:3 http://archive.ubuntu.com/ubuntu focal/universe amd64 fortunes-min all 1:1.99.1-7build1 [55.1 kB]
Fetched 615 kB in 3s (203 kB/s)    
Selecting previously unselected package librecode0:amd64.
(Reading database ... 71387 files and directories currently installed.)
Preparing to unpack .../librecode0_3.6-24_amd64.deb ...
Unpacking librecode0:amd64 (3.6-24) ...
Selecting previously unselected package fortune-mod.
Preparing to unpack .../fortune-mod_1%3a1.99.1-7build1_amd64.deb ...
Unpacking fortune-mod (1:1.99.1-7build1) ...
Selecting previously unselected package fortunes-min.
Preparing to unpack .../fortunes-min_1%3a1.99.1-7build1_all.deb ...
Unpacking fortunes-min (1:1.99.1-7build1) ...
Setting up librecode0:amd64 (3.6-24) ...
Setting up fortunes-min (1:1.99.1-7build1) ...
Setting up fortune-mod (1:1.99.1-7build1) ...
Processing triggers for man-db (2.9.1-1) ...
Processing triggers for libc-bin (2.31-0ubuntu9.1) ...
ubuntu@native-cub:~$ ddate

Command 'ddate' not found, but can be installed with:

sudo apt install ddate

ubuntu@native-cub:~$ sudo apt install ddate
Reading package lists... Done
Building dependency tree       
Reading state information... Done
The following NEW packages will be installed:
  ddate
0 upgraded, 1 newly installed, 0 to remove and 17 not upgraded.
Need to get 10.8 kB of archives.
After this operation, 34.8 kB of additional disk space will be used.
Get:1 http://archive.ubuntu.com/ubuntu focal/universe amd64 ddate amd64 0.2.2-1build1 [10.8 kB]
Fetched 10.8 kB in 1s (20.0 kB/s)
Selecting previously unselected package ddate.
(Reading database ... 71424 files and directories currently installed.)
Preparing to unpack .../ddate_0.2.2-1build1_amd64.deb ...
Unpacking ddate (0.2.2-1build1) ...
Setting up ddate (0.2.2-1build1) ...
Processing triggers for man-db (2.9.1-1) ...
ubuntu@native-cub:~$ cowsay

Command 'cowsay' not found, but can be installed with:

sudo apt install cowsay

ubuntu@native-cub:~$ sudo apt install cowsay
Reading package lists... Done
Building dependency tree       
Reading state information... Done
Suggested packages:
  filters cowsay-off
The following NEW packages will be installed:
  cowsay
0 upgraded, 1 newly installed, 0 to remove and 17 not upgraded.
Need to get 18.5 kB of archives.
After this operation, 93.2 kB of additional disk space will be used.
Get:1 http://archive.ubuntu.com/ubuntu focal/universe amd64 cowsay all 3.03+dfsg2-7 [18.5 kB]
Fetched 18.5 kB in 2s (7603 B/s) 
Selecting previously unselected package cowsay.
(Reading database ... 71431 files and directories currently installed.)
Preparing to unpack .../cowsay_3.03+dfsg2-7_all.deb ...
Unpacking cowsay (3.03+dfsg2-7) ...
Setting up cowsay (3.03+dfsg2-7) ...
Processing triggers for man-db (2.9.1-1) ...
ubuntu@native-cub:~$ </textarea>
</p>

<p>
Now we can drop back and write a script that uses these three packages to produce an interesting result. Here's what should be in the script:
</p>

<p>
<textarea cols="80" rows="5">
#!/bin/bash
ddate > /tmp/foo
echo '   ' >> /tmp/foo
fortune -s >> /tmp/foo
cat /tmp/foo | cowsay</textarea>
</p>

<p>
Add the text above to a script called motd.sh, and then chmod 777 motd.sh. Then, use the following command to copy the script to the deployed machine:
</p>

<p>
<textarea cols="80" rows="1">
scp ./motd.sh ubuntu@10.38.31.2:</textarea>
</p>

<p>
Then we can log back into the deployed machine and check the permissions on motd.sh in the arriving CWD:
</p>

<p>
<textarea cols="80" rows="7">
ssh ubuntu@10.38.31.2
...
ls -lsa motd.sh

ubuntu@native-cub:~$ ls -lsa motd.sh
4 -rwxrwxr-x 1 ubuntu ubuntu 97 Feb  1 00:49 motd.sh
ubuntu@native-cub:~$ </textarea>
</p>

<p>
On my machine, it didn't copy the permissions precisely, but it is executable by me, so I can run it and get the highly-important output:
</p>

<p>
<textarea cols="80" rows="14">
 ________________________________________
/ Today is Boomtime, the 32nd day of     \
| Chaos in the YOLD 3187                 |
|                                        |
| Water, taken in moderation cannot hurt |
| anybody.                               |
|                                        |
\ -- Mark Twain                          /
 ----------------------------------------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||</textarea>
</p>

<p>
So we see that it's possible to deploy a machine and then load usable software on it. Certainly, that's one method MAAS users depend on to get their machines configured &#x2013; probably using scripts or install packages that they scp over and kick off. There are more sophisticated ways to make this happen, and we'll cover those in the future, maybe.
</p>
</div>
</div>
</div>

<div id="outline-container-orge35259c" class="outline-2">
<h2 id="orge35259c">More neat jq things</h2>
<div class="outline-text-2" id="text-orge35259c">
<p>
I covered basic usage of jq with MAAS a couple of sections ago. Now I want to dig in a little bit, and see what else I can do with it.
</p>
</div>

<div id="outline-container-orgf094277" class="outline-3">
<h3 id="orgf094277">Sorting natively with jq</h3>
<div class="outline-text-3" id="text-orgf094277">
<p>
In my previous jq section, I showed how to use Linux command line utilities to sort lines in a multi-record jq output. It's not the only way &#x2013; nor maybe even the easiest way. The jq tool has a native sort capability. Let's take a look.
</p>

<p>
Suppose we have a random list of machines that I quickly created on one of my local MAAS installs &#x2013; haven't even bothered to commission them, since that doesn't matter here. If I run the command:
</p>

<p>
<textarea cols="80" rows="4">
maas admin machines read | jq -r '(["HOSTNAME","SYSID",
"TAGS", "POOL","ZONE"] | (., map(length*"-"))),
(.[] | [.hostname, .system_id, .tag_names[0] // "-", 
.pool.name,.zone.name]) | @tsv' | column -t</textarea>
</p>

<p>
on my very casually defined set of new machines, I'll get a listing something like this:
</p>

<p>
<textarea cols="80" rows="12">
HOSTNAME       SYSID   TAGS      POOL      ZONE
--------       -----   ----      ----      ----
nearby-louse   ed8pda  plover    swimming  defense
novel-cod      4ds3eh  dunnet    swimming  fault
nearby-koala   k6cagg  xyzzy     car       twilight
superb-koi     6sqads  xyzzy     swimming  twilight
amazed-hermit  mehgsk  xyzzy     swimming  twilight
daring-minnow  ceamb4  plover    car       demilitarized
ace-colt       hfm84c  zork      tidal     defense
unique-donkey  tsf8tk  plover    tidal     demilitarized
mutual-cod     sxbkyp  bedquilt  tidal     defense
fun-ibex       8pq6qx  zork      car       fault</textarea>
</p>

<p>
These aren't really sorted by anything, in particular, so let's just start at the front and work our way in, shall we?
sorting by one parameter
</p>

<p>
Rather than passing our output through an awk script, we can just use the jq construct for sorting, which is:
</p>

<p>
<textarea cols="80" rows="1">
sort_by(<fieldname>)</textarea>
</p>

<p>
For example, if we wanted to sort by HOSTNAME, we could try:
</p>

<p>
<textarea cols="80" rows="4">
maas admin machines read | jq -r '(["HOSTNAME","SYSID",
"TAGS", "POOL","ZONE"] | (., map(length*"-"))),
(.[] | [.hostname, .system_id, .tag_names[0] // "-", 
.pool.name,.zone.name] | sort_by(.hostname)) | @tsv' | column -t</textarea>
</p>

<p>
This doesn't give us anything like what we want, just a mysterious error:
</p>

<p>
<textarea cols="80" rows="3">
jq: error (at <stdin>:2911): Cannot index string with string "hostname"
HOSTNAME  SYSID  TAGS  POOL  ZONE
--------  -----  ----  ----  ----</textarea>
</p>

<p>
Huh? Don't you just link pipes together, and they work?
</p>
</div>
</div>

<div id="outline-container-orgb503c03" class="outline-3">
<h3 id="orgb503c03">jq is not UNIX (jqNU?)</h3>
<div class="outline-text-3" id="text-orgb503c03">
<p>
No, that's UNIX, but that's not necessarily jq. Too see what's wrong, we have to break down the earlier jq statement a little more &#x2013; you know, the one that just gives us the unsorted list:
</p>

<p>
<textarea cols="80" rows="4">
maas admin machines read | jq -r '(["HOSTNAME","SYSID",
"TAGS", "POOL","ZONE"] | (., map(length*"-"))),
(.[] | [.hostname, .system_id, .tag_names[0] // "-", 
.pool.name,.zone.name]) | @tsv' | column -t</textarea>
</p>

<p>
If we read it from left to right, we have the MAAS command that generates the JSON to begin with:
</p>

<p>
<textarea cols="80" rows="1">
maas admin machines read</textarea>
</p>

<p>
We pipe that through jq, with raw output:
</p>

<p>
<textarea cols="80" rows="1">
| jq -r</textarea>
</p>

<p>
We give jq some series of commands, between the single quotes:
</p>

<p>
<textarea cols="80" rows="1">
'(["HOSTNAME", blah, blah, blah | @tsv'</textarea>
</p>

<p>
Finally, we pipe that to column to make the columns line up nicely:
</p>

<p>
<textarea cols="80" rows="1">
| column -t</textarea>
</p>

<p>
So essentially, from a UNIX perspective, we have a data source and two filters:
</p>

<p>
<textarea cols="80" rows="1">
maas <options> | jq <options> | column <options></textarea>
</p>

<p>
The options we give to jq most definitely don't work like UNIX.
where's the data coming from?
</p>

<p>
A great question to ask yourself when building jq blocks is, "Where's the data coming from?" Let's take a closer look at the jq options:
</p>

<p>
<textarea cols="80" rows="5">
'(["HOSTNAME","SYSID","TAG","POOL","ZONE"] |
(.,map(length*"-"))),
(.[]  |
[.hostname, .system_id, .tag_names[0] // "-",.pool.name,.zone.name]) |
@tsv'</textarea>
</p>

<p>
Ask yourself where the array data is coming from. Does anything in this line retrieve data?
</p>

<p>
<textarea cols="80" rows="1">
'(["HOSTNAME","SYSID","TAG","POOL","ZONE"] |</textarea>
</p>

<p>
Nope. Those are literals, which don't retrieve any data at all. How about the next line?
</p>

<p>
<textarea cols="80" rows="1">
(.,map(length*"-"))),</textarea>
</p>

<p>
No, that line acts on data it gets, but it doesn't get data. And the next one?
</p>

<p>
<textarea cols="80" rows="1">
(.[] |</textarea>
</p>

<p>
Yep, that's it. The .[] command tells jq to iterate over what it gets. The rest of the line just tells jq which of the fields in the .[] iteration to actually retrieve.
</p>

<p>
So by process of elimination, there's only one place we could sort data &#x2013; where it comes into the command, that is, where we currently iterate over the incoming JSON arrays, .[].
</p>
</div>
</div>

<div id="outline-container-orgb1d1554" class="outline-3">
<h3 id="orgb1d1554">So how does "sortby()" work?</h3>
<div class="outline-text-3" id="text-orgb1d1554">
<p>
The "sortby()" subcommand operates on whatever it gets. In this case, we're sending it a JSON array of machine datasets. So there are two things wrong with our first attempt:
</p>

<p>
<textarea cols="80" rows="4">
maas admin machines read | jq -r '(["HOSTNAME","SYSID",
"TAGS", "POOL","ZONE"] | (., map(length*"-"))),
(.[] | [.hostname, .system_id, .tag_names[0] // "-", 
.pool.name,.zone.name] | sort_by(.hostname)) | @tsv' | column -t</textarea>
</p>

<p>
First, it's set up to handle a single JSON dataset, and sort it by a single parameter &#x2013; sort_by(.hostname) &#x2013; so there's actually nothing to sort, hence an error. Second, we trying to pipe a formatted entry from an array of JSON datasets through it, which doesn't even make any sense: you can't sort one thing.
</p>

<p>
To make the command work, we have to make sort_by itself the data source. In other words, we want jq to sort the record stream before it gets our field list, like this:
</p>

<p>
<textarea cols="80" rows="1">
maas admin machines read | jq -r '(["HOSTNAME","SYSID","TAG","POOL","ZONE"] | (., map(length*"-"))),(sort_by(.hostname)[] | [.hostname,.system_id,.tag_names[0],.pool.name,.zone.name]) | @tsv' | column -t</textarea>
</p>

<p>
As we can see, this command works as we expect:
</p>

<p>
<textarea cols="80" rows="12">
HOSTNAME       SYSID   TAG       POOL      ZONE
--------       -----   ---       ----      ----
ace-colt       hfm84c  zork      tidal     defense
amazed-hermit  mehgsk  xyzzy     swimming  twilight
daring-minnow  ceamb4  plover    car       demilitarized
fun-ibex       8pq6qx  zork      car       fault
mutual-cod     sxbkyp  bedquilt  tidal     defense
nearby-koala   k6cagg  xyzzy     car       twilight
nearby-louse   ed8pda  plover    swimming  defense
novel-cod      4ds3eh  dunnet    swimming  fault
superb-koi     6sqads  xyzzy     swimming  twilight
unique-donkey  tsf8tk  plover    tidal     demilitarized</textarea>
</p>

<p>
Reading the new command from left to right helps understand it. Basically, it reads: "Take the data for all machines from MAAS, display a heading line and a horizontal rule line; then sort the machine data by hostname, and show the following 5 parameters, in tab-separated rows, lined up in neat columns."
</p>
</div>
</div>

<div id="outline-container-org6b88ec6" class="outline-3">
<h3 id="org6b88ec6">Checking our work</h3>
<div class="outline-text-3" id="text-org6b88ec6">
<p>
We can check our work by trying different sorts:
</p>

<p>
<textarea cols="80" rows="1">
maas admin machines read | jq -r '(["HOSTNAME","SYSID","TAG","POOL","ZONE"] | (., map(length*"-"))),(sort_by(.system_id)[] | [.hostname,.system_id,.tag_names[0],.pool.name,.zone.name]) | @tsv' | column -t</textarea>
</p>

<p>
This command sorts by system ID:
</p>

<p>
<textarea cols="80" rows="12">
HOSTNAME       SYSID   TAG       POOL      ZONE
--------       -----   ---       ----      ----
novel-cod      4ds3eh  dunnet    swimming  fault
superb-koi     6sqads  xyzzy     swimming  twilight
fun-ibex       8pq6qx  zork      car       fault
daring-minnow  ceamb4  plover    car       demilitarized
nearby-louse   ed8pda  plover    swimming  defense
ace-colt       hfm84c  zork      tidal     defense
nearby-koala   k6cagg  xyzzy     car       twilight
amazed-hermit  mehgsk  xyzzy     swimming  twilight
mutual-cod     sxbkyp  bedquilt  tidal     defense
unique-donkey  tsf8tk  plover    tidal     demilitarized</textarea>
</p>

<p>
We can also try pool name:
</p>

<p>
<textarea cols="80" rows="1">
maas admin machines read | jq -r '(["HOSTNAME","SYSID","TAG","POOL","ZONE"] | (., map(length*"-"))),(sort_by(.pool.name)[] | [.hostname,.system_id,.tag_names[0],.pool.name,.zone.name]) | @tsv' | column -t</textarea>
</p>

<p>
which also works as we'd expect:
</p>

<p>
<textarea cols="80" rows="12">
HOSTNAME       SYSID   TAG       POOL      ZONE
--------       -----   ---       ----      ----
nearby-koala   k6cagg  xyzzy     car       twilight
daring-minnow  ceamb4  plover    car       demilitarized
fun-ibex       8pq6qx  zork      car       fault
nearby-louse   ed8pda  plover    swimming  defense
novel-cod      4ds3eh  dunnet    swimming  fault
superb-koi     6sqads  xyzzy     swimming  twilight
amazed-hermit  mehgsk  xyzzy     swimming  twilight
ace-colt       hfm84c  zork      tidal     defense
unique-donkey  tsf8tk  plover    tidal     demilitarized
mutual-cod     sxbkyp  bedquilt  tidal     defense</textarea>
</p>
</div>
</div>

<div id="outline-container-org03cb843" class="outline-3">
<h3 id="org03cb843">Sorting by more than one parameter</h3>
<div class="outline-text-3" id="text-org03cb843">
<p>
To sort by more than one parameter, simply include a comma-separated list of parameters for the sort, in order. For example, to sort by tag first and pool next, use this incantation:
</p>

<p>
<textarea cols="80" rows="1">
maas admin machines read | jq -r '(["HOSTNAME","SYSID","TAG","POOL","ZONE"] | (., map(length*"-"))),(sort_by(.tag_names[0],.pool.name)[] | [.hostname,.system_id,.tag_names[0],.pool.name,.zone.name]) | @tsv' | column -t</textarea>
</p>

<p>
This will give you:
</p>

<p>
<textarea cols="80" rows="10">
mutual-cod     sxbkyp  bedquilt  tidal     defense
novel-cod      4ds3eh  dunnet    swimming  fault
daring-minnow  ceamb4  plover    car       demilitarized
nearby-louse   ed8pda  plover    swimming  defense
unique-donkey  tsf8tk  plover    tidal     demilitarized
nearby-koala   k6cagg  xyzzy     car       twilight
superb-koi     6sqads  xyzzy     swimming  twilight
amazed-hermit  mehgsk  xyzzy     swimming  twilight
fun-ibex       8pq6qx  zork      car       fault
ace-colt       hfm84c  zork      tidal     defense</textarea>
</p>

<p>
You can even try three parameters. Note that I set this up with the two hosts "superb-koi" and "amazed-hermit" &#x2013; so we can use a command like this to see how multiple parameters work:
</p>

<p>
<textarea cols="80" rows="1">
maas admin machines read | jq -r '(["HOSTNAME","SYSID","TAG","POOL","ZONE"] | (., map(length*"-"))),(sort_by(.tag_names[0],.pool.name,.hostname)[] | [.hostname,.system_id,.tag_names[0],.pool.name,.zone.name]) | @tsv' | column -t</textarea>
</p>

<p>
Note that "superb-koi" and "amazed-hermit" have changed places in the listing below:
</p>

<p>
<textarea cols="80" rows="12">
HOSTNAME       SYSID   TAG       POOL      ZONE
--------       -----   ---       ----      ----
mutual-cod     sxbkyp  bedquilt  tidal     defense
novel-cod      4ds3eh  dunnet    swimming  fault
daring-minnow  ceamb4  plover    car       demilitarized
nearby-louse   ed8pda  plover    swimming  defense
unique-donkey  tsf8tk  plover    tidal     demilitarized
nearby-koala   k6cagg  xyzzy     car       twilight
amazed-hermit  mehgsk  xyzzy     swimming  twilight
superb-koi     6sqads  xyzzy     swimming  twilight
fun-ibex       8pq6qx  zork      car       fault
ace-colt       hfm84c  zork      tidal     defense</textarea>
</p>

<p>
So there's a little more jq for you, but still a lot more to learn. Might as well keep going with this, it seems to be useful to some folks &#x2013; so more jq to come.
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
Copyright (C) 2020-2023 by stormrider; All Rights Reserved
</div>
</body>
</html>