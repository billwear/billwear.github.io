

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>The Datalink Layer &mdash; billwear 1.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../_static/dark_mode_css/general.css?v=c0a7eb24" />
      <link rel="stylesheet" type="text/css" href="../_static/dark_mode_css/dark.css?v=70edf1c7" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=f2a433a1"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../_static/dark_mode_js/default_dark.js?v=fd565c74"></script>
      <script src="../_static/dark_mode_js/theme_switcher.js?v=358d3910"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="networking tutorial" href="arp.html" />
    <link rel="prev" title="The Physical Layer" href="the-physical-layer-l1.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            billwear
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">what's here?</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../philosophy/index.html">stormrider’s philosophy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../emacs/index.html">emacs</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">networking</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="complicated-channels.html">Channels of Sharing are Complicated</a></li>
<li class="toctree-l2"><a class="reference internal" href="adversarial-beginnings.html">Adversarial Beginnings</a></li>
<li class="toctree-l2"><a class="reference internal" href="reinventing-the-internet.html">Reinventing the Internet</a></li>
<li class="toctree-l2"><a class="reference internal" href="the-physical-layer-l1.html">The Physical Layer</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">The Datalink Layer</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#mac-frames">MAC Frames</a></li>
<li class="toctree-l3"><a class="reference internal" href="#ethernet">Ethernet</a></li>
<li class="toctree-l3"><a class="reference internal" href="#media-access-control-mac">Media Access Control (MAC)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#trunking-vlans">Trunking VLANs</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#the-origin-of-trunking">The Origin of “Trunking”</a></li>
<li class="toctree-l4"><a class="reference internal" href="#multiplexing-lan-channels-actually">Multiplexing LAN Channels, Actually</a></li>
<li class="toctree-l4"><a class="reference internal" href="#vlans-subnets-and-fabrics">VLANs, Subnets, and Fabrics</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#visualising-the-link-layer">Visualising the link layer</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="arp.html">networking tutorial</a></li>
<li class="toctree-l2"><a class="reference internal" href="the-network-layer-l3.html">networking tutorial</a></li>
<li class="toctree-l2"><a class="reference internal" href="the-transport-layer-l4.html">networking tutorial</a></li>
<li class="toctree-l2"><a class="reference internal" href="the-higher-layers.html">networking tutorial</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../maas/index.html">MAAS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../impatience/index.html">the impatient visionary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../amusements/index.html">amusements</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">billwear</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">networking</a></li>
      <li class="breadcrumb-item active">The Datalink Layer</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/networking/the-datalink-layer-l2.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="the-datalink-layer">
<h1>The Datalink Layer<a class="headerlink" href="#the-datalink-layer" title="Link to this heading"></a></h1>
<p>The <strong>datalink layer</strong> (the <strong>link layer</strong>, <strong>Layer 2</strong> or
<strong>L2</strong>) also has one purpose: send and receive IP datagrams. L2
doesn’t maintain a connection with the target host; it’s intentionally
“connectionless”, and it doesn’t guarantee delivery or integrity of
packets. It just ships them between source and destination. Give it a
message, give it a MAC address, and it sends it; that’s all. At first,
this message-agnostic approach may seem a little weird. L2 is not
without error-checking and recovery code, but it functions efficiently
<em>precisely</em> because it isn’t concerned with the data, or even the
message containing the data.</p>
<p>That might surprise you, especially since the word “datagram” is
sometimes used a little too freely with respect to L2. A datagram is
just a basic network transfer unit – the indivisible unit for a given
layer – <em>any</em> given layer. If we’re talking about L2, it’s an IEEE
802.xx frame. At the network layer (L3, we’ll come to that in a
minute), it’s a data packet. For the transport layer (L4), it would be
called a segment. By now, you’re probably wondering what the
indivisible units in the <em>physical layer</em> are called.</p>
<p><em>Chips</em>; they’re called chips. Beats me. But I do know that they are
<a class="reference external" href="https://en.wikipedia.org/wiki/Spread_spectrum">spread-spectrum</a>
pulses in the CDMA, noise-utilising transmission system that operates
at that layer. My advice? Unless you’re a EE with some communications
training, you might not need to go there. Since datagram isn’t
carefully used by everyone (think of User Datagram Protocol), we’ll
agree to call these indivisible layer units PDUs (protocol data
units). This avoids conflation with other uses and reminds you that
it’s the atomic unit at the current network layer. Just remember that,
at the link layer (L2), it’s a frame.</p>
<section id="mac-frames">
<h2>MAC Frames<a class="headerlink" href="#mac-frames" title="Link to this heading"></a></h2>
<p>A MAC frame, or just “frame”, encapsulates the packets from the network
layer so that they can be transmitted on the physical layer. A frame can
be small or big, anywhere from 5 bytes up to the kilobyte range. The
upper size limit is called the maximum transmission unit (MTU) or
maximum frame size. This size is set by the particular network
technology in use.</p>
<p>This last observation brings up a good point: In order to talk
sensibly about frames, we’d need to say what kind of frame. We’re
almost always talking about packet-switched networks, so there are
potentially four frame types to consider: Ethernet, fibre channel,
V.42, and PPP (point-to-point protocol). Happily, Internet networks
almost exclusively use Ethernet, as defined in the IEEE 802 standards,
so we’ll stick to that particular frame type for this
discussion. Where other frame types may come into play, we’ll discuss
those as special cases.</p>
</section>
<section id="ethernet">
<h2>Ethernet<a class="headerlink" href="#ethernet" title="Link to this heading"></a></h2>
<p>Before explaining an Ethernet Frame, we need to give a little background
information about how Ethernet works; otherwise a lot of the frame
components either won’t make sense, or you’ll wonder how it works at
all. Remember earlier, when we talked about voice radio, and the need to
say “over”? Well, Ethernet at the link layer is all about controlling
the conversation, so that computers don’t “talk over each other”.
Ethernet implements an algorithm called CSMA/CD, which stands for
“carrier sense multiple access with collision detection.” This algorithm
controls which computers can access the shared medium (an Ethernet
cable) without any special synchronisation requirements.</p>
<p>“Carrier sense” means that every NIC does what humans (should) do when
we’re talking: it waits for quiet. In this case, it’s waiting for the
network to be quiet, that is, when no signal is being sent on the
network. “Collision detection” means that, should two NICs both start
to send on a shared network at the same time (because the network was
quiet), they each receive a jam signal. This signal tells them to wait
a specific, randomly-generated amount of time before attempting
again. Every time subsequent messages collide, the NIC waits twice the
amount of time it previously waited. When it waits some maximum number
of times, the NIC will declare a failure and report that the message
didn’t go. This ensures that only one frame is traversing the network
at any given time.</p>
</section>
<section id="media-access-control-mac">
<h2>Media Access Control (MAC)<a class="headerlink" href="#media-access-control-mac" title="Link to this heading"></a></h2>
<p>Systems like CSMA/CD are a subset of the Media Access Control (MAC)
protocol kit. MAC is one-half of the link layer, with Logical Link
Control (LLC) being the other half – though these are sometimes called
sub-layers. LLC mostly just defines the frame format for the 802.xx
protocols, like WiFi, so we can safely ignore it for the moment. If
you’ve worked with networks at all, you’ve heard of MAC addresses. Those
are basically unique serial numbers assigned to network interface
devices (like NICs) at the time of manufacture.</p>
<p>Theoretically, they are unique in the world, not counting virtual NICs
in virtual machine environments. MAC address collisions do happen when
using VMs, and there are ways to fix it, assuming that your VMs are
confined to a subnet. The MAC sub-layer is connected to the physical
layer by a media-independent interface (MII), independent of the
actual link protocol (e.g, cellular broadband, Wi-Fi radio, Bluetooth,
Cat5e, T1, …). You can learn more about the MII if you’re so
inclined, but we won’t address it again in the context of this
tutorial.</p>
<p>Essentially, the MAC sub-layer grabs higher-level frames and makes
them digestible by the physical layer, by encoding them into an MII
format. It adds some synchronisation info and pads the message (if
needed). The MAC sub-layer also adds a frame check sequence that makes
it easier to identify errors. In conventional Ethernet networks, all
this looks something like the following: Let’s decode those blocks of
bits: - The Preamble is 7 bytes of clock sync, basically just zeroes
and ones like this: …0101010101… This gives the receiving station
a chance to catch up and sync their clock, so the following data isn’t
out of sync (and thus misinterpreted).</p>
<p>To delve just a little deeper, the Preamble helps the receiving NIC
figure out the exact amount of time between encoded bits (it’s called
clock recovery). NTP is nice, but Ethernet is an asynchronous LAN
protocol, meaning it doesn’t expect perfectly synchronised clocks
between any two NICs. The Preamble is similar to the way an orchestra
conductor might “count the players in” so they all get the same rhythm
to start. Before clock recovery, there was MPE. Clock recovery is much
more reliable than trying to get computers all over the world synced
up to the same clock frequency and the same downbeat (starting
point).</p>
<p>Ethernet actually started out that way with something called
Manchester Encoding or Manchester Phase Encoding (MPE). This was
important because electrical frequency varies not only across the
world, but also from moment to moment when the power is slightly
“dirty”. MPE involved bouncing a bit between two fractional voltages
using a 20MHz oscillator to generate a reference square wave. It
works, but it’s not very efficient, so MPE was scrapped in favour of
using the Preamble, the way that projectionists use alignment marks on
reels of movie film.</p>
<p>Here’s a look at the pieces:</p>
<ul class="simple">
<li><p>The Start Frame Delimiter (SFD) is the last chance for clock
sync. It is exactly 10101011, where the “11” tells the receiving
station that the real header content starts next. The receiving NIC
has to recover the clock by the time it hits the SFD, or abandon the
frame to the bit bucket.</p></li>
<li><p>The Destination Address (DAddr) is six bytes long, and gives the
physical address – the MAC address – of the next hop. Be aware
that the next hop might be the destination, but it’s also possible
that the next hop might be a NAP, MAE, NSP, or intermediate
ISP. It’s basically the next address in the direction of the
destination that the sender knows about. Unlike the Source Address,
the Destination Address can be in a broadcast format (similar to a
subnet like 192.18.0.0, but using MAC addresses).</p></li>
<li><p>The Source Address (SAddr) is also a six-byte MAC address, this time
the MAC address of the sender, which does not change as long as the
message is traversing only layer-2 (Ethernet) switches and routers.</p></li>
<li><p>The PDU Length (PDULen) gives the byte length of the entire frame,
assuming that it’s 1500 or less. If it’s longer than that, it
indicates a message type, like IPv4, ARP, or a “q-tagged” frame,
which carries a VLAN ID.</p></li>
<li><p>The DSAP, SSAP, and Control elements are each one byte in length,
and help define devices and protocols. For the most part, we won’t
be worried about these with typical networks. Just know that as more
and more 802 point-standards come out (e.g., 802.11, WiFi), these
elements get longer and more complex.</p></li>
<li><p>The Data or “Payload” is the actual packet being sent, which in the
case of TCP/IP, is just a TCP header attached to a fixed-length
chunk of the application’s data. It’s passed on from the layer
above. It cannot be less than 46 bytes, and in conventional
Ethernet, it cannot be larger than 1500 bytes. If the actual data is
too small, it’s padded out to 46 bytes.</p></li>
<li><p>The CRC or “Frame Checksum” (FCS) is a standard checksum, used to
verify that the message hasn’t been corrupted along the way.</p></li>
</ul>
<p>The Preamble and SFD are often considered to be part of the IEEE
“packet”, so some people start counting the “frame” at the Destination
Address. That distinction shouldn’t affect anything meaningful that we
do with networks, but it’s nice to keep in mind, in case you run into
someone who groups packets differently than you do.</p>
</section>
<section id="trunking-vlans">
<h2>Trunking VLANs<a class="headerlink" href="#trunking-vlans" title="Link to this heading"></a></h2>
<p>There is a crucial modification to the basic frame format called a P/Q
or VLAN Tag. This allows something called VLAN trunking, which means
sending all the VLAN data over the same wire and port, but giving the
NICs a field (the P/Q tag) to control access. On paper, it looks
something like this:</p>
<ul class="simple">
<li><p>Sixteen bits of tags or a protocol ID. - Three bits representing a
priority.</p></li>
<li><p>One bit is used as a Canonical Format Indicator (CFI), which is 0 if
the following VLAN ID is in Ethernet format, or 1 if it’s in Token
Ring format.</p></li>
<li><p>Twelve bits of VLAN ID. This matters when we’re building complex
networks with lots of VLANS that probably cross over switches. After
all, VLANs were initially controlled with ports and switches,
although they more commonly use tags now. When more than one VLAN
spans multiple switches, frames need to carry VLAN information that
can be used by switches to sort or “trunk” the traffic.</p></li>
</ul>
<section id="the-origin-of-trunking">
<h3>The Origin of “Trunking”<a class="headerlink" href="#the-origin-of-trunking" title="Link to this heading"></a></h3>
<p>The word “trunking” is derived from the telephone network term trunk
lines, which are lines connecting switchboards. In the original
telephone company model, each telephone had a subscriber line, which was
a wire that went straight from the local Central Office (CO) to that
subscriber’s telephone. Each CO had one switchboard, though it might
have many seats.</p>
<p>Connections between Central Offices were handled by trunk lines,
because they ran between phone company facilities in enclosues called
<em>cable trunks</em>. You’d have a thick cable with lots of pairs running
from CO to CO, basically enough wires to handle something like 35% of
the possible calls. If you ever got the message, “All circuits are
busy now; please try your call again later”, you’ve heard what happens
when the system is “trunking above capacity” or “TAC’d”, as it was
called.</p>
<p>At the CO, the wires would “branch” and run all over the place: First
to junction points (those five-foot-tall metal boxes you see from time
to time on the road), then to interface points (the square cans beside
the road every half mile or so, also called “pedestals”) and from
there to subscriber homes. When you draw out this network, it looks
like a tree, where the bundles of cables between COs look like the
trunks of trees.</p>
</section>
<section id="multiplexing-lan-channels-actually">
<h3>Multiplexing LAN Channels, Actually<a class="headerlink" href="#multiplexing-lan-channels-actually" title="Link to this heading"></a></h3>
<p>With VLAN trunking, by the way, we’re not just multiplexing packets,
we’re actually multiplexing LAN channels, so to speak. In the parlance
of networks, especially VLANs, the term “trunking” is used to indicate
the sharing of network routes. This sharing is made possible by the
Ethernet VLAN tags, which make the VLAN-bound messages less dependent on
switches and routers to get the traffic to the right place. Otherwise,
you’d have to designate complicated port configurations for switches,
which is particularly easy to misconfigure.</p>
<p>Note that the MAC sub-layer is responsible for managing CDMA/CD, that
is, detecting a clear line, initiating re-transmission if there’s a
jam signal, etc. On the way in, the MAC sub-layer verifies the CRC/FCS
and removes frame elements before passing the data up to the higher
layers. Basically, anything that some other MAC layer did to
encapsulate the message for sending, the receiving MAC layer un-does
on the way in.</p>
</section>
<section id="vlans-subnets-and-fabrics">
<h3>VLANs, Subnets, and Fabrics<a class="headerlink" href="#vlans-subnets-and-fabrics" title="Link to this heading"></a></h3>
<p>When working with networks, you will frequently be concerned with VLANs,
subnets, and fabrics, which are all network groupings: - Subnets define
(group) a range of IP addresses. - VLANs group subnets. - Fabrics group
VLANs. Let’s give each of these terms their due.</p>
<section id="subnets">
<h4>Subnets<a class="headerlink" href="#subnets" title="Link to this heading"></a></h4>
<p>A subnet is a range or collection of IP addresses. A subnet just means
“sub-network,” and that’s exactly what it is: a subset of IP addresses
that can be treated like a single block for some operations. Subnets are
defined in CIDR (Classless Inter-Domain Routing) notation. If you want
to use the addresses from 192.168.13.0 to 192.168.13.255 in a subnet,
you can specify that with 192.168.13.0/24. The “24” refers to the number
of bits in the subnet address, with the remainder out of 32 bits free to
address hosts. Since 8 bits can represent 256 things, that means /24
gives you the last octet, or 255 host IP addresses.</p>
<p>Whatever happened to subnet classes? Subnets used to be defined in
terms of subnet classes, like A, B, and C. That got to be a
limitation, because those three classes define a fixed number of bits
of the IP address that represent the split between subnet addresses
and host addresses. In other words, the class defined how many hosts
could be in the network, and three classes wasn’t really adequate to
address all the possible permutations that network architects
needed. The change to CIDR notation made subnets more granular,
allowing many more subnets from the same network.</p>
</section>
<section id="vlans">
<h4>VLANs<a class="headerlink" href="#vlans" title="Link to this heading"></a></h4>
<p>A VLAN used to be a series of IP addresses that could access a given
port on a specific switch, generally the switch that gated some
protected resource. With the advent of VLAN trunking (see above), VLANs
are marked with the 802.1Q (P/Q) bits in the MAC frame. In theory, any
set of addresses can be associated with any VLAN.</p>
<p>Let me strongly encourage a correspondence of subnets to VLANs. Every
IP should be in exactly one subnet, and every subnet should be part of
exactly one VLAN.  You don’t have to do that: you could, for example,
have two different subnets that overlap, like 192.168.43.0/24 and
192.168.43.0/26. The “.26” subnet would use fewer bits for the host
addresses, so only some of the addresses would overlap.</p>
<p>A decent network designer generally avoids this kind of address
overlap. Likewise, putting one subnet in two different VLANs might be
possible, but it isn’t practical or easy to debug when conflicts
happen. You should endeavour to enforce a clean “fan-out” across the
network, with no possibility of conflicting IP addresses.</p>
</section>
<section id="fabrics">
<h4>Fabrics<a class="headerlink" href="#fabrics" title="Link to this heading"></a></h4>
<p>A fabric just collects VLANs together. If you stick to the clean
fan-out, that also means that a fabric collects subnets. A fabric
provides a higher level grouping. Consider an example: Suppose you have
one VLAN for HR, and one VLAN for payroll, so that nobody else can see
HR’s private files, and likewise you’ve got payroll data limited to just
those people who should see it.</p>
<p>Some executives are entitled to see anything and everything about the
corporation. An “executive” fabric would group all VLANs together, so
that people admitted to that fabric can access the VLANs without
having to be explicitly added to each one.  That’s very handy in
really large organisations, saving a lot of time and effort.</p>
</section>
</section>
</section>
<section id="visualising-the-link-layer">
<h2>Visualising the link layer<a class="headerlink" href="#visualising-the-link-layer" title="Link to this heading"></a></h2>
<p>Let’s start with a message coming on Layer 1 from SanDiego to Bangor.
When the message comes in, the link layer does the following things:</p>
<ul class="simple">
<li><p>It synchronises the NIC, so that bits will indeed be recognised as
bits and the message can be properly decoded.</p></li>
<li><p>It handles the source and destination addresses, using ARP as
necessary.</p></li>
<li><p>It interprets the length/type bytes and uses them, which means it
must judge the length of a frame, and of the data in a frame, or,
alternatively, decide whether a frame is IPv4, ARP, or VLAN
(“q-tagged”).</p></li>
<li><p>It processes VLAN tags, which means, at the very least, dealing with
the message priority, deciding whether the VLAN frame is Ethernet or
Token Ring, and capturing and using the VLAN ID. The layer handles
messages by priority, knows how and when to send Ethernet or Token
Ring frames, and knows how to route traffic to a specific VLAN.</p></li>
<li><p>It computes the checksum to make sure the message is valid.</p></li>
</ul>
<p>Next, we’ll take a look at the network layer, where most of the
message transactions take place, and where most of our debugging will
be done.</p>
<hr class="docutils" />
<p>Copyright (C) 2024 by Bill Wear; All Rights Reserved</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="the-physical-layer-l1.html" class="btn btn-neutral float-left" title="The Physical Layer" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="arp.html" class="btn btn-neutral float-right" title="networking tutorial" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, bill wear.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>