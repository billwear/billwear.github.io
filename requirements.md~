<head>
  <link rel="icon" href="/favicon.svg" type="image/svg+xml">
  <link rel="stylesheet" href="/styles.css">
</head>

      <a href="/">← back to billwear</a>
# How to write engineering requirements

    <main>
## The language of requirements
          * **shall** — binding, testable, mandatory.<br>
              Example: <em>The system **shall** encrypt all stored passwords using bcrypt.</em>
          * **should** — desirable but not mandatory.<br>
              Example: <em>The API **should** respond within 200&nbsp;ms under normal load.</em>
          * **will** — statement of fact or intent, not a requirement.<br>
              Example: <em>Data **will** be archived for seven years under company policy.</em>
      </section>

## How to organize requirements
          <ol>
          * **Hierarchy matters:** start with system-level requirements, then decompose into subsystem and component requirements.
          * **Unique IDs:** number everything (e.g., REQ-1.2.3). Don’t delete IDs; mark obsolete instead.
          * **Atomic statements:** one thought per requirement. Avoid “and/or.”
          * **Traceability:** link each requirement to its source (stakeholder, regulation, standard). Map downward to design and test cases.
          * **Verification focus:** every <em>shall</em> must be verifiable by test, analysis, inspection, or demonstration.
          </ol>
      </section>

## Examples
          * REQ-1.1: The device shall operate continuously for 8 hours on battery power. [Test]
	  * REQ-1.2: The user interface should support dark mode. [Inspection]
	  * REQ-1.3: The product will be manufactured in Austin, TX. [Context only]
      </section>

## Checklist before you publish
          * Each <em>shall</em> has a clear verification method.
          * No requirement mixes multiple ideas.
          * Numbering and trace links are consistent.
          * Stakeholders can understand it without a decoder ring.
      </section>
    </main>

      CC BY-NC 2025 · stormrider

**CC BY-NC 2025 stormrider**
